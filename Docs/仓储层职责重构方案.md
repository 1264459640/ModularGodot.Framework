# 仓储层职责重构方案

## 问题分析

你提出了一个关键的架构设计问题：**仓储层是否还应该有实现底层技术的职责？**

基于当前项目中的实现（如 `CacheManager`、`ResourceLoaderRepo` 等），我发现仓储层确实承担了大量底层技术实现的职责。这违反了**单一职责原则**和**分层架构**的设计理念。

## 当前问题分析

### 1. 当前仓储层的职责过重

```csharp
// 当前的ResourceLoaderRepo承担了太多职责
public class ResourceLoaderRepo : BaseRepo, IResourceLoaderRepo
{
    // ❌ 底层技术实现：缓存管理
    private readonly CacheManager<string, Resource> _cache = new();
    
    // ❌ 底层技术实现：内存监控
    private readonly MemoryMonitor _memoryMonitor = new();
    
    // ❌ 底层技术实现：引用跟踪
    private readonly ReferenceTracker _referenceTracker = new();
    
    // ❌ 底层技术实现：统计收集
    private readonly StatsCollector _statsCollector = new();
    
    // ❌ 底层技术实现：预加载队列
    private readonly ConcurrentQueue<string> _preloadQueue = new();
    
    // ✅ 仓储职责：资源加载逻辑
    public Resource? LoadResource(string path, CachePolicy policy = CachePolicy.Normal)
    {
        // 业务逻辑与底层实现混合
        if (_cache.TryGetValue(path, out var cachedResource))
        {
            _statsCollector.RecordCacheHit(); // 底层实现
            _referenceTracker.Increase(path); // 底层实现
            return cachedResource.Resource;
        }
        
        var resource = ResourceLoader.Load(path); // Godot API调用
        // ...
    }
}
```

### 2. 职责混乱的问题

**当前架构的问题**：
1. **职责不清**：仓储层既负责业务逻辑又负责底层实现
2. **难以测试**：底层技术实现与业务逻辑耦合
3. **难以替换**：底层技术变更影响仓储层
4. **违反SRP**：一个类承担多个变化原因
5. **难以扩展**：新增底层技术需要修改仓储层

## 重构方案：分层职责设计

### 1. 新的分层架构

```
应用层 (Application Layer)
    ↓ 调用
服务层 (Service Layer)
    ↓ 调用
仓储层 (Repository Layer) ← 只负责数据访问抽象
    ↓ 调用
基础设施层 (Infrastructure Layer) ← 负责底层技术实现
    ↓ 调用
技术实现层 (Technical Implementation Layer) ← 具体技术细节
```

### 2. 重新定义仓储层职责

**仓储层应该只负责**：
- **数据访问抽象**：定义数据访问的契约
- **业务查询逻辑**：实现业务相关的查询逻辑
- **数据映射转换**：在领域对象和数据对象之间转换
- **事务协调**：协调跨多个数据源的事务

**仓储层不应该负责**：
- **缓存实现**：应该由基础设施层提供
- **连接管理**：应该由技术实现层处理
- **性能监控**：应该由基础设施层提供
- **序列化/反序列化**：应该由技术实现层处理

### 3. 重构后的架构设计

```csharp
// ✅ 重构后的仓储层：只负责数据访问抽象
namespace MF.Repositories.Abstractions
{
    /// <summary>
    /// 资源仓储接口：只定义业务契约
    /// </summary>
    public interface IResourceRepository
    {
        Task<TResource?> GetResourceAsync<TResource>(string path) where TResource : Resource;
        Task<IEnumerable<TResource>> GetResourcesAsync<TResource>(IEnumerable<string> paths) where TResource : Resource;
        Task<bool> ExistsAsync(string path);
        Task PreloadResourceAsync(string path);
        Task<ResourceMetadata> GetMetadataAsync(string path);
        Task InvalidateAsync(string path);
        Task InvalidateAllAsync();
    }
    
    /// <summary>
    /// 资源仓储实现：只负责业务逻辑
    /// </summary>
    public class ResourceRepository : IResourceRepository
    {
        // ✅ 依赖注入：基础设施服务
        private readonly IResourceLoader _resourceLoader;
        private readonly ICacheService _cacheService;
        private readonly IResourceValidator _validator;
        private readonly ILogger<ResourceRepository> _logger;
        
        public ResourceRepository(
            IResourceLoader resourceLoader,
            ICacheService cacheService,
            IResourceValidator validator,
            ILogger<ResourceRepository> logger)
        {
            _resourceLoader = resourceLoader;
            _cacheService = cacheService;
            _validator = validator;
            _logger = logger;
        }
        
        // ✅ 只负责业务逻辑：资源获取的业务流程
        public async Task<TResource?> GetResourceAsync<TResource>(string path) where TResource : Resource
        {
            _logger.LogDebug($"Getting resource: {path}");
            
            // 业务验证
            if (!_validator.IsValidPath(path))
            {
                throw new ArgumentException($"Invalid resource path: {path}");
            }
            
            // 尝试从缓存获取（委托给基础设施层）
            var cachedResource = await _cacheService.GetAsync<TResource>(path);
            if (cachedResource != null)
            {
                _logger.LogDebug($"Resource found in cache: {path}");
                return cachedResource;
            }
            
            // 从存储加载（委托给基础设施层）
            var resource = await _resourceLoader.LoadAsync<TResource>(path);
            if (resource == null)
            {
                _logger.LogWarning($"Resource not found: {path}");
                return null;
            }
            
            // 缓存资源（委托给基础设施层）
            await _cacheService.SetAsync(path, resource);
            
            _logger.LogDebug($"Resource loaded successfully: {path}");
            return resource;
        }
        
        // ✅ 业务逻辑：批量资源获取
        public async Task<IEnumerable<TResource>> GetResourcesAsync<TResource>(IEnumerable<string> paths) where TResource : Resource
        {
            var tasks = paths.Select(path => GetResourceAsync<TResource>(path));
            var results = await Task.WhenAll(tasks);
            return results.Where(r => r != null).Cast<TResource>();
        }
        
        // ✅ 业务逻辑：预加载策略
        public async Task PreloadResourceAsync(string path)
        {
            _logger.LogDebug($"Preloading resource: {path}");
            
            // 检查是否已经缓存
            if (await _cacheService.ExistsAsync(path))
            {
                _logger.LogDebug($"Resource already cached: {path}");
                return;
            }
            
            // 异步预加载
            _ = Task.Run(async () =>
            {
                try
                {
                    await GetResourceAsync<Resource>(path);
                    _logger.LogDebug($"Resource preloaded: {path}");
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, $"Failed to preload resource: {path}");
                }
            });
        }
    }
}
```

### 4. 基础设施层：底层技术实现

```csharp
// ✅ 基础设施层：负责底层技术实现
namespace MF.Infrastructure.Caching
{
    /// <summary>
    /// 缓存服务接口
    /// </summary>
    public interface ICacheService
    {
        Task<T?> GetAsync<T>(string key) where T : class;
        Task SetAsync<T>(string key, T value, TimeSpan? expiration = null) where T : class;
        Task<bool> ExistsAsync(string key);
        Task RemoveAsync(string key);
        Task ClearAsync();
        Task<CacheStatistics> GetStatisticsAsync();
    }
    
    /// <summary>
    /// 内存缓存服务实现
    /// </summary>
    public class MemoryCacheService : ICacheService
    {
        private readonly IMemoryCache _memoryCache;
        private readonly ICacheStatistics _statistics;
        private readonly ILogger<MemoryCacheService> _logger;
        
        public MemoryCacheService(
            IMemoryCache memoryCache,
            ICacheStatistics statistics,
            ILogger<MemoryCacheService> logger)
        {
            _memoryCache = memoryCache;
            _statistics = statistics;
            _logger = logger;
        }
        
        public async Task<T?> GetAsync<T>(string key) where T : class
        {
            if (_memoryCache.TryGetValue(key, out var value))
            {
                _statistics.RecordHit();
                _logger.LogTrace($"Cache hit: {key}");
                return value as T;
            }
            
            _statistics.RecordMiss();
            _logger.LogTrace($"Cache miss: {key}");
            return null;
        }
        
        public async Task SetAsync<T>(string key, T value, TimeSpan? expiration = null) where T : class
        {
            var options = new MemoryCacheEntryOptions();
            
            if (expiration.HasValue)
            {
                options.AbsoluteExpirationRelativeToNow = expiration;
            }
            
            // 设置缓存大小限制
            options.Size = CalculateSize(value);
            
            // 设置缓存优先级
            options.Priority = CacheItemPriority.Normal;
            
            // 设置过期回调
            options.PostEvictionCallbacks.Add(new PostEvictionCallbackRegistration
            {
                EvictionCallback = OnCacheEvicted,
                State = key
            });
            
            _memoryCache.Set(key, value, options);
            _statistics.RecordSet();
            _logger.LogTrace($"Cache set: {key}");
        }
        
        private void OnCacheEvicted(object key, object value, EvictionReason reason, object state)
        {
            _statistics.RecordEviction(reason);
            _logger.LogTrace($"Cache evicted: {key}, Reason: {reason}");
        }
        
        private long CalculateSize<T>(T value) where T : class
        {
            // 简单的大小计算，实际实现可能更复杂
            if (value is Resource resource)
            {
                return EstimateResourceSize(resource);
            }
            
            return 1; // 默认大小
        }
        
        private long EstimateResourceSize(Resource resource)
        {
            return resource switch
            {
                Texture2D texture => texture.GetWidth() * texture.GetHeight() * 4, // RGBA
                AudioStream audio => 1024 * 1024, // 估算1MB
                PackedScene scene => 512 * 1024, // 估算512KB
                _ => 1024 // 默认1KB
            };
        }
    }
    
    /// <summary>
    /// 分布式缓存服务实现
    /// </summary>
    public class DistributedCacheService : ICacheService
    {
        private readonly IDistributedCache _distributedCache;
        private readonly ISerializer _serializer;
        private readonly ICacheStatistics _statistics;
        private readonly ILogger<DistributedCacheService> _logger;
        
        public DistributedCacheService(
            IDistributedCache distributedCache,
            ISerializer serializer,
            ICacheStatistics statistics,
            ILogger<DistributedCacheService> logger)
        {
            _distributedCache = distributedCache;
            _serializer = serializer;
            _statistics = statistics;
            _logger = logger;
        }
        
        public async Task<T?> GetAsync<T>(string key) where T : class
        {
            try
            {
                var data = await _distributedCache.GetAsync(key);
                if (data == null)
                {
                    _statistics.RecordMiss();
                    return null;
                }
                
                var value = _serializer.Deserialize<T>(data);
                _statistics.RecordHit();
                return value;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Failed to get from distributed cache: {key}");
                _statistics.RecordError();
                return null;
            }
        }
        
        public async Task SetAsync<T>(string key, T value, TimeSpan? expiration = null) where T : class
        {
            try
            {
                var data = _serializer.Serialize(value);
                var options = new DistributedCacheEntryOptions();
                
                if (expiration.HasValue)
                {
                    options.AbsoluteExpirationRelativeToNow = expiration;
                }
                
                await _distributedCache.SetAsync(key, data, options);
                _statistics.RecordSet();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Failed to set distributed cache: {key}");
                _statistics.RecordError();
            }
        }
    }
}
```

### 5. 技术实现层：具体技术细节

```csharp
// ✅ 技术实现层：Godot特定的资源加载实现
namespace MF.Infrastructure.ResourceLoading
{
    /// <summary>
    /// 资源加载器接口
    /// </summary>
    public interface IResourceLoader
    {
        Task<T?> LoadAsync<T>(string path) where T : Resource;
        Task<bool> ExistsAsync(string path);
        Task<ResourceMetadata> GetMetadataAsync(string path);
        Task PreloadAsync(string path);
    }
    
    /// <summary>
    /// Godot资源加载器实现
    /// </summary>
    public class GodotResourceLoader : IResourceLoader
    {
        private readonly ILogger<GodotResourceLoader> _logger;
        private readonly ResourceLoadingConfig _config;
        private readonly SemaphoreSlim _loadingSemaphore;
        
        public GodotResourceLoader(
            ILogger<GodotResourceLoader> logger,
            ResourceLoadingConfig config)
        {
            _logger = logger;
            _config = config;
            _loadingSemaphore = new SemaphoreSlim(_config.MaxConcurrentLoads, _config.MaxConcurrentLoads);
        }
        
        public async Task<T?> LoadAsync<T>(string path) where T : Resource
        {
            await _loadingSemaphore.WaitAsync();
            
            try
            {
                _logger.LogTrace($"Loading resource: {path}");
                
                // 使用Godot的ResourceLoader
                var resource = await Task.Run(() => ResourceLoader.Load(path));
                
                if (resource == null)
                {
                    _logger.LogWarning($"Resource not found: {path}");
                    return null;
                }
                
                if (resource is not T typedResource)
                {
                    _logger.LogError($"Resource type mismatch. Expected: {typeof(T).Name}, Actual: {resource.GetType().Name}");
                    return null;
                }
                
                _logger.LogTrace($"Resource loaded successfully: {path}");
                return typedResource;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, $"Failed to load resource: {path}");
                return null;
            }
            finally
            {
                _loadingSemaphore.Release();
            }
        }
        
        public async Task<bool> ExistsAsync(string path)
        {
            return await Task.Run(() => ResourceLoader.Exists(path));
        }
        
        public async Task<ResourceMetadata> GetMetadataAsync(string path)
        {
            return await Task.Run(() =>
            {
                var fileAccess = FileAccess.Open(path, FileAccess.ModeFlags.Read);
                if (fileAccess == null)
                {
                    return new ResourceMetadata { Path = path, Exists = false };
                }
                
                var metadata = new ResourceMetadata
                {
                    Path = path,
                    Exists = true,
                    Size = (long)fileAccess.GetLength(),
                    LastModified = DateTime.FromFileTime(fileAccess.GetModifiedTime())
                };
                
                fileAccess.Close();
                return metadata;
            });
        }
        
        public async Task PreloadAsync(string path)
        {
            _logger.LogTrace($"Preloading resource: {path}");
            
            // 异步预加载，不阻塞当前线程
            _ = Task.Run(async () =>
            {
                try
                {
                    await LoadAsync<Resource>(path);
                    _logger.LogTrace($"Resource preloaded: {path}");
                }
                catch (Exception ex)
                {
                }
            });
        }
    }
    
    /// <summary>
    /// 资源加载配置
    /// </summary>
    public class ResourceLoadingConfig
    {
        public int MaxConcurrentLoads { get; set; } = 4;
        public TimeSpan LoadTimeout { get; set; } = TimeSpan.FromSeconds(30);
        public bool EnablePreloading { get; set; } = true;
        public string[] PreloadPaths { get; set; } = Array.Empty<string>();
    }
    
    /// <summary>
    /// 资源元数据
    /// </summary>
    public class ResourceMetadata
    {
        public string Path { get; set; } = string.Empty;
        public bool Exists { get; set; }
        public long Size { get; set; }
        public DateTime LastModified { get; set; }
        public string ResourceType { get; set; } = string.Empty;
    }
}
```

### 6. 监控和统计层

```csharp
// ✅ 监控统计层：独立的横切关注点
namespace MF.Infrastructure.Monitoring
{
    /// <summary>
    /// 缓存统计接口
    /// </summary>
    public interface ICacheStatistics
    {
        void RecordHit();
        void RecordMiss();
        void RecordSet();
        void RecordEviction(EvictionReason reason);
        void RecordError();
        CacheStatistics GetStatistics();
        void Reset();
    }
    
    /// <summary>
    /// 缓存统计实现
    /// </summary>
    public class CacheStatistics : ICacheStatistics
    {
        private long _hits;
        private long _misses;
        private long _sets;
        private long _evictions;
        private long _errors;
        private readonly Dictionary<EvictionReason, long> _evictionReasons = new();
        private readonly object _lock = new();
        
        public void RecordHit() => Interlocked.Increment(ref _hits);
        public void RecordMiss() => Interlocked.Increment(ref _misses);
        public void RecordSet() => Interlocked.Increment(ref _sets);
        public void RecordError() => Interlocked.Increment(ref _errors);
        
        public void RecordEviction(EvictionReason reason)
        {
            Interlocked.Increment(ref _evictions);
            
            lock (_lock)
            {
                _evictionReasons.TryGetValue(reason, out var count);
                _evictionReasons[reason] = count + 1;
            }
        }
        
        public CacheStatistics GetStatistics()
        {
            lock (_lock)
            {
                var total = _hits + _misses;
                var hitRate = total > 0 ? (double)_hits / total : 0.0;
                
                return new CacheStatistics
                {
                    Hits = _hits,
                    Misses = _misses,
                    Sets = _sets,
                    Evictions = _evictions,
                    Errors = _errors,
                    HitRate = hitRate,
                    EvictionReasons = new Dictionary<EvictionReason, long>(_evictionReasons)
                };
            }
        }
        
        public void Reset()
        {
            lock (_lock)
            {
                _hits = 0;
                _misses = 0;
                _sets = 0;
                _evictions = 0;
                _errors = 0;
                _evictionReasons.Clear();
            }
        }
    }
    
    /// <summary>
    /// 性能监控服务
    /// </summary>
    public class PerformanceMonitor : IPerformanceMonitor
    {
        private readonly ILogger<PerformanceMonitor> _logger;
        private readonly Timer _reportTimer;
        private readonly ICacheStatistics _cacheStatistics;
        
        public PerformanceMonitor(
            ILogger<PerformanceMonitor> logger,
            ICacheStatistics cacheStatistics)
        {
            _logger = logger;
            _cacheStatistics = cacheStatistics;
            
            // 每分钟报告一次统计信息
            _reportTimer = new Timer(ReportStatistics, null, TimeSpan.FromMinutes(1), TimeSpan.FromMinutes(1));
        }
        
        private void ReportStatistics(object? state)
        {
            try
            {
                var stats = _cacheStatistics.GetStatistics();
                
                _logger.LogInformation(
                    "Cache Statistics - Hits: {Hits}, Misses: {Misses}, Hit Rate: {HitRate:P2}, Sets: {Sets}, Evictions: {Evictions}, Errors: {Errors}",
                    stats.Hits, stats.Misses, stats.HitRate, stats.Sets, stats.Evictions, stats.Errors);
                
                // 检查性能警告
                if (stats.HitRate < 0.8 && stats.Hits + stats.Misses > 100)
                {
                    _logger.LogWarning("Cache hit rate is low: {HitRate:P2}", stats.HitRate);
                }
                
                if (stats.Errors > 0)
                {
                    _logger.LogWarning("Cache errors detected: {Errors}", stats.Errors);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to report cache statistics");
            }
        }
        
        public void Dispose()
        {
            _reportTimer?.Dispose();
        }
    }
}
```

## 依赖注入配置

### 1. 服务注册

```csharp
// ✅ 依赖注入配置：清晰的分层注册
namespace MF.Infrastructure.DependencyInjection
{
    public static class ServiceCollectionExtensions
    {
        public static IServiceCollection AddRepositoryLayer(this IServiceCollection services)
        {
            // 仓储层：只注册业务逻辑
            services.AddScoped<IResourceRepository, ResourceRepository>();
            services.AddScoped<IPlayerRepository, PlayerRepository>();
            services.AddScoped<IGameDataRepository, GameDataRepository>();
            
            return services;
        }
        
        public static IServiceCollection AddInfrastructureLayer(this IServiceCollection services, IConfiguration configuration)
        {
            // 基础设施层：注册技术服务
            
            // 缓存服务
            var cacheConfig = configuration.GetSection("Cache").Get<CacheConfig>();
            if (cacheConfig?.UseDistributedCache == true)
            {
                services.AddStackExchangeRedisCache(options =>
                {
                    options.Configuration = cacheConfig.RedisConnectionString;
                });
                services.AddScoped<ICacheService, DistributedCacheService>();
            }
            else
            {
                services.AddMemoryCache(options =>
                {
                    options.SizeLimit = cacheConfig?.MemoryCacheSizeLimit ?? 100 * 1024 * 1024; // 100MB
                });
                services.AddScoped<ICacheService, MemoryCacheService>();
            }
            
            // 资源加载服务
            services.Configure<ResourceLoadingConfig>(configuration.GetSection("ResourceLoading"));
            services.AddScoped<IResourceLoader, GodotResourceLoader>();
            
            // 验证服务
            services.AddScoped<IResourceValidator, ResourceValidator>();
            
            // 序列化服务
            services.AddScoped<ISerializer, JsonSerializer>();
            
            // 监控统计服务
            services.AddSingleton<ICacheStatistics, CacheStatistics>();
            services.AddSingleton<IPerformanceMonitor, PerformanceMonitor>();
            
            return services;
        }
        
        public static IServiceCollection AddTechnicalLayer(this IServiceCollection services)
        {
            // 技术实现层：注册具体技术实现
            
            // Godot特定服务
            services.AddSingleton<IGodotResourceManager, GodotResourceManager>();
            services.AddSingleton<IGodotFileSystem, GodotFileSystem>();
            
            // 平台特定服务
            if (OS.GetName() == "Windows")
            {
                services.AddSingleton<IPlatformService, WindowsPlatformService>();
            }
            else if (OS.GetName() == "Linux")
            {
                services.AddSingleton<IPlatformService, LinuxPlatformService>();
            }
            
            return services;
        }
    }
    
    /// <summary>
    /// 缓存配置
    /// </summary>
    public class CacheConfig
    {
        public bool UseDistributedCache { get; set; } = false;
        public string RedisConnectionString { get; set; } = string.Empty;
        public long MemoryCacheSizeLimit { get; set; } = 100 * 1024 * 1024; // 100MB
        public TimeSpan DefaultExpiration { get; set; } = TimeSpan.FromHours(1);
    }
}
```

### 2. 配置文件

```json
// appsettings.json
{
  "Cache": {
    "UseDistributedCache": false,
    "RedisConnectionString": "localhost:6379",
    "MemoryCacheSizeLimit": 104857600,
    "DefaultExpiration": "01:00:00"
  },
  "ResourceLoading": {
    "MaxConcurrentLoads": 4,
    "LoadTimeout": "00:00:30",
    "EnablePreloading": true,
    "PreloadPaths": [
      "res://assets/ui/",
      "res://assets/audio/common/"
    ]
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "MF.Infrastructure": "Debug",
      "MF.Repositories": "Information"
    }
  }
}
```

## 重构的优势

### 1. 清晰的职责分离

| 层次 | 职责 | 示例 |
|------|------|------|
| **仓储层** | 数据访问抽象、业务查询逻辑 | `IResourceRepository`、查询组合 |
| **基础设施层** | 技术服务提供、横切关注点 | `ICacheService`、`ILogger` |
| **技术实现层** | 具体技术实现、平台特定代码 | `GodotResourceLoader`、平台API |

### 2. 更好的可测试性

```csharp
// ✅ 仓储层测试：只需要Mock基础设施服务
[Test]
public async Task GetResourceAsync_ShouldReturnCachedResource_WhenResourceExistsInCache()
{
    // Arrange
    var mockCacheService = new Mock<ICacheService>();
    var mockResourceLoader = new Mock<IResourceLoader>();
    var mockValidator = new Mock<IResourceValidator>();
    var mockLogger = new Mock<ILogger<ResourceRepository>>();
    
    var expectedResource = new Texture2D();
    mockValidator.Setup(v => v.IsValidPath("test.png")).Returns(true);
    mockCacheService.Setup(c => c.GetAsync<Texture2D>("test.png"))
                   .ReturnsAsync(expectedResource);
    
    var repository = new ResourceRepository(
        mockResourceLoader.Object,
        mockCacheService.Object,
        mockValidator.Object,
        mockLogger.Object);
    
    // Act
    var result = await repository.GetResourceAsync<Texture2D>("test.png");
    
    // Assert
    Assert.AreEqual(expectedResource, result);
    mockResourceLoader.Verify(l => l.LoadAsync<Texture2D>(It.IsAny<string>()), Times.Never);
}
```

### 3. 更好的可扩展性

```csharp
// ✅ 新增缓存策略：不影响仓储层
public class HybridCacheService : ICacheService
{
    private readonly ICacheService _memoryCache;
    private readonly ICacheService _distributedCache;
    
    public async Task<T?> GetAsync<T>(string key) where T : class
    {
        // 先查内存缓存
        var result = await _memoryCache.GetAsync<T>(key);
        if (result != null)
            return result;
        
        // 再查分布式缓存
        result = await _distributedCache.GetAsync<T>(key);
        if (result != null)
        {
            // 回写到内存缓存
            await _memoryCache.SetAsync(key, result, TimeSpan.FromMinutes(5));
        }
        
        return result;
    }
}
```

### 4. 更好的配置灵活性

```csharp
// ✅ 运行时切换实现：不影响业务代码
services.AddScoped<ICacheService>(provider =>
{
    var config = provider.GetService<CacheConfig>();
    var logger = provider.GetService<ILogger<ICacheService>>();
    
    return config.CacheStrategy switch
    {
        "Memory" => new MemoryCacheService(provider.GetService<IMemoryCache>(), logger),
        "Distributed" => new DistributedCacheService(provider.GetService<IDistributedCache>(), logger),
        "Hybrid" => new HybridCacheService(
            new MemoryCacheService(provider.GetService<IMemoryCache>(), logger),
            new DistributedCacheService(provider.GetService<IDistributedCache>(), logger)),
        _ => new MemoryCacheService(provider.GetService<IMemoryCache>(), logger)
    };
});
```

## 迁移策略

### 1. 渐进式重构

**第一阶段**：抽取基础设施服务
- 创建 `ICacheService` 接口和实现
- 创建 `IResourceLoader` 接口和实现
- 保持现有仓储层不变

**第二阶段**：重构仓储层
- 修改仓储层使用新的基础设施服务
- 移除仓储层中的底层技术实现
- 添加单元测试

**第三阶段**：优化和扩展
- 添加监控和统计功能
- 优化性能和配置
- 添加新的缓存策略

### 2. 兼容性保证

```csharp
// ✅ 适配器模式：保证向后兼容
public class LegacyResourceLoaderAdapter : IResourceLoaderRepo
{
    private readonly IResourceRepository _newRepository;
    
    public LegacyResourceLoaderAdapter(IResourceRepository newRepository)
    {
        _newRepository = newRepository;
    }
    
    // 适配旧接口到新实现
    public Resource? LoadResource(string path, CachePolicy policy = CachePolicy.Normal)
    {
        return _newRepository.GetResourceAsync<Resource>(path).GetAwaiter().GetResult();
    }
}
```

## 总结

### 核心观点

**仓储层不应该负责底层技术实现**，应该专注于：
1. **数据访问抽象**：定义清晰的数据访问契约
2. **业务查询逻辑**：实现业务相关的查询和操作
3. **数据转换映射**：在不同数据表示之间转换
4. **事务协调**：协调跨数据源的操作

### 重构收益

1. **职责清晰**：每层都有明确的职责边界
2. **易于测试**：仓储层可以独立测试
3. **技术无关**：仓储层不依赖具体技术实现
4. **易于扩展**：新增技术实现不影响业务逻辑
5. **配置灵活**：可以运行时切换不同实现

### 实施建议

1. **渐进式重构**：分阶段进行，保证系统稳定
2. **接口优先**：先定义接口，再实现具体类
3. **测试驱动**：为每个层次编写充分的测试
4. **配置外化**：通过配置文件控制技术选择
5. **监控完善**：添加完善的监控和日志

这种分层设计既保持了架构的清晰性，又提供了足够的灵活性来应对技术变化和业务需求的演进。