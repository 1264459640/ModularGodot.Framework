# 指令（Command）设计原则

本文档用于规范本仓库中 MediatR 指令与处理器的设计与实现，确保“指令由服务（业务能力）提供，节点仅作为发起方”，并在不改变现有依赖边界的前提下，提升可维护性与可扩展性。

## 适用范围与约束
- 适用范围：MF.Commands 下的命令与结果，MF.CommandHandlers 下的处理器；包含资源加载、压力测试等能力。
- 约束前提：
  - 不改变当前项目依赖边界与分布；
  - 表示层（Godot Node）仅构造并发送命令，不接触处理器实现；
  - 处理器仅依赖服务接口（而非 Godot API）。

## 分层与依赖方向
- 契约层（命令/结果）：由服务侧定义并拥有，承载业务意图与数据。
- 应用层（处理器）：实现命令用例，依赖抽象服务接口进行实际操作。
- 表示层（Godot）：只负责输入收集、命令发送、结果展示。
- 依赖方向：UI(Node) → MediatR(IRequest) → Handler → 领域/服务接口实现。

## 命令契约设计（Commands/Results）
- 纯数据：仅使用基础类型、字符串、枚举、轻量 DTO；禁止出现 Godot 类型或 Node 引用。
- 不含行为：命令不内置执行逻辑；仅表达“意图 + 数据”。
- 不可变：优先使用 record，不可变属性；构造完成即完整。
- 可追踪：预留或支持注入 CorrelationId 以串联日志与指标。
- 可演进：新增字段需具备默认值与后向兼容；避免破坏性变更。
- 语义化命名：动宾结构，如 ResourceLoadCommand、ResourceStressTestCommand；枚举名强调业务语义。
- 统一结果：提供 Success/Failed 工厂、错误码与消息；承载关键诊断信息（耗时、统计等）。

## 处理器设计（Handlers）
- 单一职责：一个处理器只处理一个命令，逻辑内聚，副作用边界清晰。
- 依赖接口：仅依赖抽象服务（如 IResourceLoaderService、ITelemetry、IGameLogger）；禁止直接访问 Godot API。
- 可取消：处理器必须接收 CancellationToken；在循环、等待、批处理边界检查取消并尽快退出。
- 输入验证：对命令参数进行校验（空/格式/范围）；失败返回失败结果而非抛异常。
- 错误边界：
  - 预期错误（如资源不存在、类型不匹配）→ 失败结果（携带错误码、可诊断信息）；
  - 非预期异常 → 捕获、记录、转译（避免把堆栈透传给 UI）。
- 日志：入口/出口与关键阶段输出结构化日志（包含 CorrelationId、关键参数与结果摘要）；避免日志风暴。
- 性能：I/O 异步化；并发有上限（参数或配置驱动）；必要时产出聚合诊断指标（吞吐、分位耗时、峰值并发、GC 次数等）。
- 线程模型：禁止触碰 Godot 主线程对象；如需 UI 交互，定义 IUiDispatcherService 由服务层实现，处理器仅调用接口。

## 取消与超时
- UI 必须向 MediatR 传递 CancellationToken；处理器在密集循环/等待处检查取消。
- 默认不在处理器内强加固定超时；若业务需要，作为命令可选参数或由上层调用设置超时。

## 错误处理与结果规范
- 失败结果需包含：错误码、用户可理解的消息、关键诊断字段（不敏感）。
- 统一错误码策略：集中管理常见错误码（如 Common.Unexpected、Resource.NotFound、Resource.TypeMismatch）。
- 禁止泄露敏感信息（如内部绝对路径、机密配置、堆栈）。

## 日志与遥测
- 统一使用 IGameLogger；分级输出 Info/Warning/Error。
- 指标建议：每个命令记录请求计数、成功率、失败率、平均/分位耗时；压力类命令记录峰值并发、内存与 GC 指标。
- 关联追踪：日志与指标通过同一 CorrelationId 串联请求链路。

## 性能与资源
- 资源访问：封装在服务接口（如 IResourceLoaderService）中，处理器只依赖接口；路径与类型解析集中管理。
- 并发与背压：支持可配置并发；长任务提供阶段性进度聚合（写入 Result.Diagnostics）。
- 内存：避免一次性加载超大集合；按需分页/分批。

## Godot 线程与对象约束
- 主线程禁令：处理器严禁访问 Node/Scene/Texture 等 Godot 对象。
- UI 更新：由 UI 层消费结果数据自行渲染；确需回调主线程时，通过 IUiDispatcherService 调度。

## 命名与组织
- 目录与命名空间：命令放置于 MF.Commands，处理器放置于 MF.CommandHandlers；命名空间与目录一致。
- 命名：{Feature}{Action}Command；处理器为 {CommandName}Handler；结果为 {CommandName}Result 或领域化 Result。
- 枚举与 DTO：置于同命名空间的小文件或与命令同文件；避免跨层引用 Godot 类型。

## 版本化与兼容
- 新增字段遵循“可选、可默认”的加法原则；避免破坏性删除或重命名。
- 弃用策略：Obsolete 标注并给出迁移路径；保留过渡期。

## 安全与边界
- 输入清理：路径、名称、数量等参数白名单或范围校验。
- 资源隔离：命令执行不得突破资源根目录范围；外部输入必须净化。
- 最小权限：处理器仅依赖所需接口能力，避免过宽接口暴露。

## 测试策略
- 单元测试：以处理器为单位，用桩替换服务接口；覆盖成功/失败/取消/边界参数。
- 集成测试：在容器内验证接口实现的协作，不引入 Godot Node。
- 性能/压力：为压力类命令提供指标基线（吞吐、内存上限、取消响应时间）。

## 定义完成（DoD）
- 命令：无 Godot 类型、不可变、可取消、可版本化、字段有注释说明。
- 处理器：依赖接口、无 UI 访问、验证完备、取消与错误处理齐备、关键日志与指标齐全。
- 测试：单元/必要的集成与性能测试覆盖关键路径。

## 反模式清单（禁止项）
- 命令/处理器直接访问 Godot Node 或主线程对象。
- 命令字段携带 UI 语义（如“按钮名/面板名”）。
- 将异常原样抛给 UI，或在处理器内书写 UI 文本。
- 未传递/未检查 CancellationToken；无上限并发导致资源枯竭。
- 命令包含可变引用或隐式外部状态。

## 与现有实现的契合建议
- ResourceLoadCommand/Handler：保持 record 契约与 Success/Failed 工厂；处理器经由 IResourceLoaderService 访问资源并做类型校验；在批处理或等待点检查取消；日志包含资源数量、加载耗时、成功/失败摘要。
- ResourceStressTestCommand/Handler：密集循环中增加取消检查；将 Godot 相关访问封装到服务接口；结果中提供阶段性聚合诊断（吞吐、内存/GC），避免 UI 轮询内部状态。
- UI（如 ResourceStressTest 节点）：仅构造命令并展示结果；传递 CancellationToken；停止按钮只触发 Cancel，不做“假停止”。

## 推进清单（落地顺序建议）
1) 为所有命令补充 CorrelationId、默认值与注释说明；
2) 为处理器补充入口/出口与关键阶段日志、取消检查、错误码分支；
3) 引入/规范 IResourceLoaderService、IUiDispatcherService 等接口对 Godot 访问做隔离；
4) 建立错误码表的最小清单与约定；
5) 为每个命令编写最小单元测试（成功/失败/取消）。

— 完 —