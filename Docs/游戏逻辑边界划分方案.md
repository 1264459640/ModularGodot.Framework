# 游戏逻辑边界划分方案

## 问题分析

你提出了一个游戏架构中的核心难题：**游戏节点的交互显示与业务逻辑边界模糊**。这个问题在传统的企业级CQRS架构中并不常见，但在游戏开发中却是普遍存在的挑战。

### 游戏特有的复杂性

与传统的企业应用不同，游戏中的"业务逻辑"具有以下特点：

1. **状态机逻辑**：玩家控制、敌人AI都有复杂的状态转换
2. **实时交互**：需要60FPS的实时响应
3. **空间关系**：涉及位置、碰撞、物理等空间计算
4. **行为树**：AI决策需要复杂的行为逻辑
5. **动画状态**：视觉表现与逻辑状态紧密耦合

## 重新定义游戏架构边界

### 传统分层 vs 游戏分层

**传统企业架构**：
```
表现层 (UI) → 应用层 (Services) → 领域层 (Business Logic) → 数据层 (Repository)
```

**游戏架构重新定义**：
```
渲染层 (Rendering) → 表现层 (Presentation) → 游戏逻辑层 (Game Logic) → 数据层 (Data)
                                    ↓
                            实体组件系统 (ECS)
                                    ↓
                            系统层 (Systems)
```

### 新的边界划分原则

#### 1. 按职责而非技术分层

**渲染职责**：
- 图形渲染
- 动画播放
- 特效显示
- UI绘制

**表现职责**：
- 输入处理
- 状态可视化
- 用户反馈
- 界面逻辑

**游戏逻辑职责**：
- 状态机管理
- AI决策
- 物理模拟
- 游戏规则

**数据职责**：
- 状态持久化
- 配置管理
- 存档系统

#### 2. 基于实体组件系统(ECS)的架构

```csharp
// 实体：游戏对象的唯一标识
public struct Entity
{
    public uint Id { get; }
    public Entity(uint id) => Id = id;
}

// 组件：纯数据，无逻辑
public interface IComponent { }

// 位置组件
public struct PositionComponent : IComponent
{
    public Vector2 Position;
    public float Rotation;
}

// 移动组件
public struct MovementComponent : IComponent
{
    public Vector2 Velocity;
    public float Speed;
    public Vector2 Direction;
}

// 状态机组件
public struct StateMachineComponent : IComponent
{
    public string CurrentState;
    public Dictionary<string, IState> States;
    public float StateTime;
}

// AI组件
public struct AIComponent : IComponent
{
    public IBehaviorTree BehaviorTree;
    public Dictionary<string, object> Blackboard;
    public float DecisionCooldown;
}

// 渲染组件
public struct RenderComponent : IComponent
{
    public string SpritePath;
    public Color Tint;
    public Vector2 Scale;
    public int ZIndex;
}

// 动画组件
public struct AnimationComponent : IComponent
{
    public string CurrentAnimation;
    public float AnimationTime;
    public Dictionary<string, AnimationData> Animations;
}
```

#### 3. 系统：处理特定组件组合的逻辑

```csharp
// 系统基类
public abstract class GameSystem
{
    protected IEntityManager EntityManager { get; }
    protected IEventBus EventBus { get; }
    
    public abstract void Update(float deltaTime);
    public abstract void FixedUpdate(float fixedDeltaTime);
}

// 移动系统：处理位置和移动组件
public class MovementSystem : GameSystem
{
    public override void Update(float deltaTime)
    {
        // 查询所有具有位置和移动组件的实体
        var entities = EntityManager.GetEntitiesWith<PositionComponent, MovementComponent>();
        
        foreach (var entity in entities)
        {
            ref var position = ref EntityManager.GetComponent<PositionComponent>(entity);
            ref var movement = ref EntityManager.GetComponent<MovementComponent>(entity);
            
            // 更新位置
            position.Position += movement.Velocity * deltaTime;
            
            // 发布移动事件
            EventBus.PublishAsync(new EntityMovedEvent
            {
                EntityId = entity.Id,
                OldPosition = position.Position - movement.Velocity * deltaTime,
                NewPosition = position.Position,
                Velocity = movement.Velocity
            });
        }
    }
}

// 状态机系统：处理状态转换逻辑
public class StateMachineSystem : GameSystem
{
    public override void Update(float deltaTime)
    {
        var entities = EntityManager.GetEntitiesWith<StateMachineComponent>();
        
        foreach (var entity in entities)
        {
            ref var stateMachine = ref EntityManager.GetComponent<StateMachineComponent>(entity);
            
            // 更新状态时间
            stateMachine.StateTime += deltaTime;
            
            // 获取当前状态
            if (stateMachine.States.TryGetValue(stateMachine.CurrentState, out var currentState))
            {
                // 更新状态
                var nextState = currentState.Update(entity, deltaTime);
                
                // 状态转换
                if (nextState != null && nextState != stateMachine.CurrentState)
                {
                    TransitionToState(entity, ref stateMachine, nextState);
                }
            }
        }
    }
    
    private void TransitionToState(Entity entity, ref StateMachineComponent stateMachine, string newState)
    {
        var oldState = stateMachine.CurrentState;
        
        // 退出当前状态
        if (stateMachine.States.TryGetValue(oldState, out var exitingState))
        {
            exitingState.Exit(entity);
        }
        
        // 进入新状态
        if (stateMachine.States.TryGetValue(newState, out var enteringState))
        {
            enteringState.Enter(entity);
            stateMachine.CurrentState = newState;
            stateMachine.StateTime = 0f;
            
            // 发布状态变化事件
            EventBus.PublishAsync(new StateChangedEvent
            {
                EntityId = entity.Id,
                OldState = oldState,
                NewState = newState
            });
        }
    }
}

// AI系统：处理AI决策逻辑
public class AISystem : GameSystem
{
    public override void Update(float deltaTime)
    {
        var entities = EntityManager.GetEntitiesWith<AIComponent>();
        
        foreach (var entity in entities)
        {
            ref var ai = ref EntityManager.GetComponent<AIComponent>(entity);
            
            // 更新决策冷却
            ai.DecisionCooldown -= deltaTime;
            
            // 执行行为树
            if (ai.DecisionCooldown <= 0f)
            {
                var result = ai.BehaviorTree.Execute(entity, ai.Blackboard);
                
                // 根据结果设置冷却时间
                ai.DecisionCooldown = result switch
                {
                    BehaviorResult.Success => 0.1f,
                    BehaviorResult.Failure => 0.5f,
                    BehaviorResult.Running => 0.016f, // 每帧执行
                    _ => 0.1f
                };
                
                // 发布AI决策事件
                EventBus.PublishAsync(new AIDecisionEvent
                {
                    EntityId = entity.Id,
                    Decision = result,
                    Blackboard = new Dictionary<string, object>(ai.Blackboard)
                });
            }
        }
    }
}
```

## 状态机架构设计

### 1. 状态接口定义

```csharp
// 状态接口
public interface IState
{
    string Name { get; }
    void Enter(Entity entity);
    string Update(Entity entity, float deltaTime);
    void Exit(Entity entity);
}

// 状态基类
public abstract class GameState : IState
{
    public abstract string Name { get; }
    protected IEntityManager EntityManager { get; }
    protected IEventBus EventBus { get; }
    
    public virtual void Enter(Entity entity)
    {
        EventBus.PublishAsync(new StateEnteredEvent
        {
            EntityId = entity.Id,
            StateName = Name
        });
    }
    
    public abstract string Update(Entity entity, float deltaTime);
    
    public virtual void Exit(Entity entity)
    {
        EventBus.PublishAsync(new StateExitedEvent
        {
            EntityId = entity.Id,
            StateName = Name
        });
    }
}
```

### 2. 玩家状态机实现

```csharp
// 玩家空闲状态
public class PlayerIdleState : GameState
{
    public override string Name => "Idle";
    
    public override string Update(Entity entity, float deltaTime)
    {
        // 检查输入
        if (EntityManager.HasComponent<InputComponent>(entity))
        {
            var input = EntityManager.GetComponent<InputComponent>(entity);
            
            if (input.MoveInput != Vector2.Zero)
            {
                return "Moving";
            }
            
            if (input.AttackPressed)
            {
                return "Attacking";
            }
            
            if (input.JumpPressed && IsGrounded(entity))
            {
                return "Jumping";
            }
        }
        
        return null; // 保持当前状态
    }
    
    private bool IsGrounded(Entity entity)
    {
        // 检查是否在地面上的逻辑
        return EntityManager.HasComponent<GroundedComponent>(entity);
    }
}

// 玩家移动状态
public class PlayerMovingState : GameState
{
    public override string Name => "Moving";
    
    public override void Enter(Entity entity)
    {
        base.Enter(entity);
        
        // 开始移动动画
        if (EntityManager.HasComponent<AnimationComponent>(entity))
        {
            ref var animation = ref EntityManager.GetComponent<AnimationComponent>(entity);
            animation.CurrentAnimation = "Walk";
            animation.AnimationTime = 0f;
        }
    }
    
    public override string Update(Entity entity, float deltaTime)
    {
        if (EntityManager.HasComponent<InputComponent>(entity))
        {
            var input = EntityManager.GetComponent<InputComponent>(entity);
            
            // 没有移动输入，回到空闲状态
            if (input.MoveInput == Vector2.Zero)
            {
                return "Idle";
            }
            
            // 更新移动组件
            if (EntityManager.HasComponent<MovementComponent>(entity))
            {
                ref var movement = ref EntityManager.GetComponent<MovementComponent>(entity);
                movement.Direction = input.MoveInput.Normalized();
                movement.Velocity = movement.Direction * movement.Speed;
            }
            
            // 检查攻击输入
            if (input.AttackPressed)
            {
                return "Attacking";
            }
            
            // 检查跳跃输入
            if (input.JumpPressed && IsGrounded(entity))
            {
                return "Jumping";
            }
        }
        
        return null;
    }
    
    public override void Exit(Entity entity)
    {
        base.Exit(entity);
        
        // 停止移动
        if (EntityManager.HasComponent<MovementComponent>(entity))
        {
            ref var movement = ref EntityManager.GetComponent<MovementComponent>(entity);
            movement.Velocity = Vector2.Zero;
        }
    }
    
    private bool IsGrounded(Entity entity)
    {
        return EntityManager.HasComponent<GroundedComponent>(entity);
    }
}

// 玩家攻击状态
public class PlayerAttackingState : GameState
{
    public override string Name => "Attacking";
    private float _attackDuration = 0.5f;
    
    public override void Enter(Entity entity)
    {
        base.Enter(entity);
        
        // 开始攻击动画
        if (EntityManager.HasComponent<AnimationComponent>(entity))
        {
            ref var animation = ref EntityManager.GetComponent<AnimationComponent>(entity);
            animation.CurrentAnimation = "Attack";
            animation.AnimationTime = 0f;
        }
        
        // 停止移动
        if (EntityManager.HasComponent<MovementComponent>(entity))
        {
            ref var movement = ref EntityManager.GetComponent<MovementComponent>(entity);
            movement.Velocity = Vector2.Zero;
        }
    }
    
    public override string Update(Entity entity, float deltaTime)
    {
        var stateMachine = EntityManager.GetComponent<StateMachineComponent>(entity);
        
        // 攻击动画播放完毕
        if (stateMachine.StateTime >= _attackDuration)
        {
            // 执行攻击逻辑
            PerformAttack(entity);
            
            // 检查是否有移动输入
            if (EntityManager.HasComponent<InputComponent>(entity))
            {
                var input = EntityManager.GetComponent<InputComponent>(entity);
                if (input.MoveInput != Vector2.Zero)
                {
                    return "Moving";
                }
            }
            
            return "Idle";
        }
        
        return null;
    }
    
    private void PerformAttack(Entity entity)
    {
        // 发布攻击事件
        EventBus.PublishAsync(new AttackExecutedEvent
        {
            AttackerId = entity.Id,
            AttackType = "MeleeAttack",
            Damage = 25.0f,
            Position = EntityManager.GetComponent<PositionComponent>(entity).Position
        });
    }
}
```

### 3. 敌人AI状态机

```csharp
// 敌人巡逻状态
public class EnemyPatrolState : GameState
{
    public override string Name => "Patrol";
    
    public override string Update(Entity entity, float deltaTime)
    {
        // 检查是否发现玩家
        var playerEntity = FindNearbyPlayer(entity);
        if (playerEntity.HasValue)
        {
            // 设置追击目标
            if (EntityManager.HasComponent<AIComponent>(entity))
            {
                ref var ai = ref EntityManager.GetComponent<AIComponent>(entity);
                ai.Blackboard["TargetEntity"] = playerEntity.Value;
            }
            
            return "Chasing";
        }
        
        // 继续巡逻逻辑
        UpdatePatrolMovement(entity, deltaTime);
        
        return null;
    }
    
    private Entity? FindNearbyPlayer(Entity entity)
    {
        var position = EntityManager.GetComponent<PositionComponent>(entity).Position;
        var detectionRange = 100.0f;
        
        // 查找附近的玩家实体
        var playerEntities = EntityManager.GetEntitiesWith<PlayerComponent, PositionComponent>();
        
        foreach (var playerEntity in playerEntities)
        {
            var playerPosition = EntityManager.GetComponent<PositionComponent>(playerEntity).Position;
            var distance = Vector2.Distance(position, playerPosition);
            
            if (distance <= detectionRange)
            {
                return playerEntity;
            }
        }
        
        return null;
    }
    
    private void UpdatePatrolMovement(Entity entity, float deltaTime)
    {
        // 简单的巡逻逻辑：在两点之间移动
        if (EntityManager.HasComponent<PatrolComponent>(entity))
        {
            ref var patrol = ref EntityManager.GetComponent<PatrolComponent>(entity);
            ref var position = ref EntityManager.GetComponent<PositionComponent>(entity);
            ref var movement = ref EntityManager.GetComponent<MovementComponent>(entity);
            
            var targetPoint = patrol.PatrolPoints[patrol.CurrentTargetIndex];
            var direction = (targetPoint - position.Position).Normalized();
            
            movement.Direction = direction;
            movement.Velocity = direction * movement.Speed * 0.5f; // 巡逻时速度较慢
            
            // 到达目标点，切换到下一个点
            if (Vector2.Distance(position.Position, targetPoint) < 10.0f)
            {
                patrol.CurrentTargetIndex = (patrol.CurrentTargetIndex + 1) % patrol.PatrolPoints.Length;
            }
        }
    }
}

// 敌人追击状态
public class EnemyChasingState : GameState
{
    public override string Name => "Chasing";
    
    public override string Update(Entity entity, float deltaTime)
    {
        if (EntityManager.HasComponent<AIComponent>(entity))
        {
            var ai = EntityManager.GetComponent<AIComponent>(entity);
            
            if (ai.Blackboard.TryGetValue("TargetEntity", out var targetObj) && targetObj is Entity targetEntity)
            {
                var position = EntityManager.GetComponent<PositionComponent>(entity).Position;
                var targetPosition = EntityManager.GetComponent<PositionComponent>(targetEntity).Position;
                var distance = Vector2.Distance(position, targetPosition);
                
                // 目标太远，回到巡逻状态
                if (distance > 200.0f)
                {
                    return "Patrol";
                }
                
                // 足够接近，进入攻击状态
                if (distance < 30.0f)
                {
                    return "Attacking";
                }
                
                // 继续追击
                UpdateChaseMovement(entity, targetPosition);
            }
            else
            {
                // 没有目标，回到巡逻
                return "Patrol";
            }
        }
        
        return null;
    }
    
    private void UpdateChaseMovement(Entity entity, Vector2 targetPosition)
    {
        ref var position = ref EntityManager.GetComponent<PositionComponent>(entity);
        ref var movement = ref EntityManager.GetComponent<MovementComponent>(entity);
        
        var direction = (targetPosition - position.Position).Normalized();
        movement.Direction = direction;
        movement.Velocity = direction * movement.Speed; // 追击时全速
    }
}
```

## 行为树架构设计

### 1. 行为树节点定义

```csharp
// 行为结果枚举
public enum BehaviorResult
{
    Success,
    Failure,
    Running
}

// 行为树节点基类
public abstract class BehaviorNode
{
    public abstract BehaviorResult Execute(Entity entity, Dictionary<string, object> blackboard);
}

// 复合节点基类
public abstract class CompositeNode : BehaviorNode
{
    protected List<BehaviorNode> Children { get; } = new();
    
    public void AddChild(BehaviorNode child)
    {
        Children.Add(child);
    }
}

// 选择器节点：依次执行子节点，直到有一个成功
public class SelectorNode : CompositeNode
{
    public override BehaviorResult Execute(Entity entity, Dictionary<string, object> blackboard)
    {
        foreach (var child in Children)
        {
            var result = child.Execute(entity, blackboard);
            
            if (result == BehaviorResult.Success || result == BehaviorResult.Running)
            {
                return result;
            }
        }
        
        return BehaviorResult.Failure;
    }
}

// 序列节点：依次执行子节点，直到有一个失败
public class SequenceNode : CompositeNode
{
    public override BehaviorResult Execute(Entity entity, Dictionary<string, object> blackboard)
    {
        foreach (var child in Children)
        {
            var result = child.Execute(entity, blackboard);
            
            if (result == BehaviorResult.Failure || result == BehaviorResult.Running)
            {
                return result;
            }
        }
        
        return BehaviorResult.Success;
    }
}

// 并行节点：同时执行所有子节点
public class ParallelNode : CompositeNode
{
    private readonly int _successThreshold;
    
    public ParallelNode(int successThreshold = 1)
    {
        _successThreshold = successThreshold;
    }
    
    public override BehaviorResult Execute(Entity entity, Dictionary<string, object> blackboard)
    {
        int successCount = 0;
        int runningCount = 0;
        
        foreach (var child in Children)
        {
            var result = child.Execute(entity, blackboard);
            
            switch (result)
            {
                case BehaviorResult.Success:
                    successCount++;
                    break;
                case BehaviorResult.Running:
                    runningCount++;
                    break;
            }
        }
        
        if (successCount >= _successThreshold)
        {
            return BehaviorResult.Success;
        }
        
        if (runningCount > 0)
        {
            return BehaviorResult.Running;
        }
        
        return BehaviorResult.Failure;
    }
}
```

### 2. 叶子节点实现

```csharp
// 条件节点：检查是否发现玩家
public class IsPlayerNearbyCondition : BehaviorNode
{
    private readonly float _detectionRange;
    
    public IsPlayerNearbyCondition(float detectionRange = 100.0f)
    {
        _detectionRange = detectionRange;
    }
    
    public override BehaviorResult Execute(Entity entity, Dictionary<string, object> blackboard)
    {
        var entityManager = ServiceLocator.GetService<IEntityManager>();
        var position = entityManager.GetComponent<PositionComponent>(entity).Position;
        
        // 查找附近的玩家
        var playerEntities = entityManager.GetEntitiesWith<PlayerComponent, PositionComponent>();
        
        foreach (var playerEntity in playerEntities)
        {
            var playerPosition = entityManager.GetComponent<PositionComponent>(playerEntity).Position;
            var distance = Vector2.Distance(position, playerPosition);
            
            if (distance <= _detectionRange)
            {
                blackboard["TargetEntity"] = playerEntity;
                blackboard["TargetPosition"] = playerPosition;
                return BehaviorResult.Success;
            }
        }
        
        return BehaviorResult.Failure;
    }
}

// 动作节点：移动到目标位置
public class MoveToTargetAction : BehaviorNode
{
    private readonly float _acceptableDistance;
    
    public MoveToTargetAction(float acceptableDistance = 5.0f)
    {
        _acceptableDistance = acceptableDistance;
    }
    
    public override BehaviorResult Execute(Entity entity, Dictionary<string, object> blackboard)
    {
        if (!blackboard.TryGetValue("TargetPosition", out var targetObj) || targetObj is not Vector2 targetPosition)
        {
            return BehaviorResult.Failure;
        }
        
        var entityManager = ServiceLocator.GetService<IEntityManager>();
        ref var position = ref entityManager.GetComponent<PositionComponent>(entity);
        ref var movement = ref entityManager.GetComponent<MovementComponent>(entity);
        
        var distance = Vector2.Distance(position.Position, targetPosition);
        
        // 已经到达目标位置
        if (distance <= _acceptableDistance)
        {
            movement.Velocity = Vector2.Zero;
            return BehaviorResult.Success;
        }
        
        // 继续移动
        var direction = (targetPosition - position.Position).Normalized();
        movement.Direction = direction;
        movement.Velocity = direction * movement.Speed;
        
        return BehaviorResult.Running;
    }
}

// 动作节点：攻击目标
public class AttackTargetAction : BehaviorNode
{
    private readonly float _attackRange;
    private readonly float _attackCooldown;
    
    public AttackTargetAction(float attackRange = 30.0f, float attackCooldown = 1.0f)
    {
        _attackRange = attackRange;
        _attackCooldown = attackCooldown;
    }
    
    public override BehaviorResult Execute(Entity entity, Dictionary<string, object> blackboard)
    {
        if (!blackboard.TryGetValue("TargetEntity", out var targetObj) || targetObj is not Entity targetEntity)
        {
            return BehaviorResult.Failure;
        }
        
        var entityManager = ServiceLocator.GetService<IEntityManager>();
        var eventBus = ServiceLocator.GetService<IEventBus>();
        
        var position = entityManager.GetComponent<PositionComponent>(entity).Position;
        var targetPosition = entityManager.GetComponent<PositionComponent>(targetEntity).Position;
        var distance = Vector2.Distance(position, targetPosition);
        
        // 目标超出攻击范围
        if (distance > _attackRange)
        {
            return BehaviorResult.Failure;
        }
        
        // 检查攻击冷却
        var lastAttackTime = blackboard.TryGetValue("LastAttackTime", out var timeObj) ? (float)timeObj : 0f;
        var currentTime = Time.GetUnixTimeFromSystem();
        
        if (currentTime - lastAttackTime < _attackCooldown)
        {
            return BehaviorResult.Running;
        }
        
        // 执行攻击
        eventBus.PublishAsync(new AttackExecutedEvent
        {
            AttackerId = entity.Id,
            TargetId = targetEntity.Id,
            AttackType = "EnemyAttack",
            Damage = 15.0f,
            Position = position
        });
        
        blackboard["LastAttackTime"] = currentTime;
        
        return BehaviorResult.Success;
    }
}
```

### 3. 敌人AI行为树构建

```csharp
// 敌人AI行为树工厂
public class EnemyBehaviorTreeFactory
{
    public static IBehaviorTree CreateBasicEnemyBehaviorTree()
    {
        // 构建行为树：
        // Selector
        // ├── Sequence (攻击序列)
        // │   ├── IsPlayerNearby (近距离)
        // │   └── AttackTarget
        // ├── Sequence (追击序列)
        // │   ├── IsPlayerNearby (中距离)
        // │   └── MoveToTarget
        // └── Patrol (默认巡逻)
        
        var root = new SelectorNode();
        
        // 攻击序列
        var attackSequence = new SequenceNode();
        attackSequence.AddChild(new IsPlayerNearbyCondition(30.0f)); // 近距离检测
        attackSequence.AddChild(new AttackTargetAction());
        
        // 追击序列
        var chaseSequence = new SequenceNode();
        chaseSequence.AddChild(new IsPlayerNearbyCondition(100.0f)); // 中距离检测
        chaseSequence.AddChild(new MoveToTargetAction());
        
        // 巡逻行为
        var patrolAction = new PatrolAction();
        
        root.AddChild(attackSequence);
        root.AddChild(chaseSequence);
        root.AddChild(patrolAction);
        
        return new BehaviorTree(root);
    }
    
    public static IBehaviorTree CreateAdvancedEnemyBehaviorTree()
    {
        // 更复杂的行为树，包含更多策略
        var root = new SelectorNode();
        
        // 逃跑序列（生命值低时）
        var fleeSequence = new SequenceNode();
        fleeSequence.AddChild(new IsHealthLowCondition(0.3f));
        fleeSequence.AddChild(new FleeFromPlayerAction());
        
        // 群体攻击序列（有盟友时）
        var groupAttackSequence = new SequenceNode();
        groupAttackSequence.AddChild(new HasAlliesNearbyCondition());
        groupAttackSequence.AddChild(new IsPlayerNearbyCondition(50.0f));
        groupAttackSequence.AddChild(new GroupAttackAction());
        
        // 单独攻击序列
        var soloAttackSequence = new SequenceNode();
        soloAttackSequence.AddChild(new IsPlayerNearbyCondition(30.0f));
        soloAttackSequence.AddChild(new AttackTargetAction());
        
        // 追击序列
        var chaseSequence = new SequenceNode();
        chaseSequence.AddChild(new IsPlayerNearbyCondition(100.0f));
        chaseSequence.AddChild(new MoveToTargetAction());
        
        // 巡逻
        var patrolAction = new PatrolAction();
        
        root.AddChild(fleeSequence);
        root.AddChild(groupAttackSequence);
        root.AddChild(soloAttackSequence);
        root.AddChild(chaseSequence);
        root.AddChild(patrolAction);
        
        return new BehaviorTree(root);
    }
}
```

## 与CQRS架构的集成

### 1. 游戏命令定义

```csharp
// 游戏特有的命令
public record CreateEntityCommand(string EntityType, Vector2 Position, Dictionary<string, object> Properties) : GameCommand;

public record DestroyEntityCommand(uint EntityId) : GameCommand;

public record AddComponentCommand<T>(uint EntityId, T Component) : GameCommand where T : IComponent;

public record RemoveComponentCommand<T>(uint EntityId) : GameCommand where T : IComponent;

public record ChangeStateCommand(uint EntityId, string NewState) : GameCommand;

public record UpdateAIBlackboardCommand(uint EntityId, string Key, object Value) : GameCommand;

// 玩家输入命令
public record PlayerInputCommand(uint PlayerId, Vector2 MoveInput, bool AttackPressed, bool JumpPressed) : GameCommand;

// AI决策命令
public record ExecuteAIDecisionCommand(uint EntityId) : GameCommand;
```

### 2. 游戏事件定义

```csharp
// 实体相关事件
public record EntityCreatedEvent : GameEvent
{
    public uint EntityId { get; init; }
    public string EntityType { get; init; }
    public Vector2 Position { get; init; }
}

public record EntityDestroyedEvent : GameEvent
{
    public uint EntityId { get; init; }
}

public record ComponentAddedEvent<T> : GameEvent where T : IComponent
{
    public uint EntityId { get; init; }
    public T Component { get; init; }
}

// 状态机事件
public record StateChangedEvent : GameEvent
{
    public uint EntityId { get; init; }
    public string OldState { get; init; }
    public string NewState { get; init; }
}

// AI事件
public record AIDecisionEvent : GameEvent
{
    public uint EntityId { get; init; }
    public BehaviorResult Decision { get; init; }
    public Dictionary<string, object> Blackboard { get; init; }
}

// 游戏逻辑事件
public record AttackExecutedEvent : GameEvent
{
    public uint AttackerId { get; init; }
    public uint? TargetId { get; init; }
    public string AttackType { get; init; }
    public float Damage { get; init; }
    public Vector2 Position { get; init; }
}

public record EntityMovedEvent : GameEvent
{
    public uint EntityId { get; init; }
    public Vector2 OldPosition { get; init; }
    public Vector2 NewPosition { get; init; }
    public Vector2 Velocity { get; init; }
}
```

### 3. 命令处理器实现

```csharp
// 实体管理命令处理器
public class CreateEntityCommandHandler : GameCommandHandler<CreateEntityCommand>
{
    private readonly IEntityManager _entityManager;
    
    public CreateEntityCommandHandler(IEntityManager entityManager, IEventBus eventBus, ILogger<CreateEntityCommandHandler> logger)
        : base(eventBus, logger)
    {
        _entityManager = entityManager;
    }
    
    protected override async Task HandleCommandAsync(CreateEntityCommand command, CancellationToken cancellationToken)
    {
        var entity = _entityManager.CreateEntity();
        
        // 添加基础组件
        _entityManager.AddComponent(entity, new PositionComponent { Position = command.Position });
        
        // 根据实体类型添加特定组件
        switch (command.EntityType)
        {
            case "Player":
                _entityManager.AddComponent(entity, new PlayerComponent());
                _entityManager.AddComponent(entity, new MovementComponent { Speed = 300.0f });
                _entityManager.AddComponent(entity, new InputComponent());
                _entityManager.AddComponent(entity, CreatePlayerStateMachine());
                break;
                
            case "Enemy":
                _entityManager.AddComponent(entity, new EnemyComponent());
                _entityManager.AddComponent(entity, new MovementComponent { Speed = 150.0f });
                _entityManager.AddComponent(entity, new AIComponent 
                { 
                    BehaviorTree = EnemyBehaviorTreeFactory.CreateBasicEnemyBehaviorTree(),
                    Blackboard = new Dictionary<string, object>()
                });
                _entityManager.AddComponent(entity, CreateEnemyStateMachine());
                break;
        }
        
        // 发布实体创建事件
        await PublishEventAsync(new EntityCreatedEvent
        {
            CorrelationId = command.CommandId,
            EntityId = entity.Id,
            EntityType = command.EntityType,
            Position = command.Position
        });
    }
    
    private StateMachineComponent CreatePlayerStateMachine()
    {
        var states = new Dictionary<string, IState>
        {
            { "Idle", new PlayerIdleState() },
            { "Moving", new PlayerMovingState() },
            { "Attacking", new PlayerAttackingState() },
            { "Jumping", new PlayerJumpingState() }
        };
        
        return new StateMachineComponent
        {
            CurrentState = "Idle",
            States = states,
            StateTime = 0f
        };
    }
    
    private StateMachineComponent CreateEnemyStateMachine()
    {
        var states = new Dictionary<string, IState>
        {
            { "Patrol", new EnemyPatrolState() },
            { "Chasing", new EnemyChasingState() },
            { "Attacking", new EnemyAttackingState() }
        };
        
        return new StateMachineComponent
        {
            CurrentState = "Patrol",
            States = states,
            StateTime = 0f
        };
    }
}

// 玩家输入命令处理器
public class PlayerInputCommandHandler : GameCommandHandler<PlayerInputCommand>
{
    private readonly IEntityManager _entityManager;
    
    public PlayerInputCommandHandler(IEntityManager entityManager, IEventBus eventBus, ILogger<PlayerInputCommandHandler> logger)
        : base(eventBus, logger)
    {
        _entityManager = entityManager;
    }
    
    protected override async Task HandleCommandAsync(PlayerInputCommand command, CancellationToken cancellationToken)
    {
        var entity = new Entity(command.PlayerId);
        
        if (_entityManager.HasComponent<InputComponent>(entity))
        {
            ref var input = ref _entityManager.GetComponent<InputComponent>(entity);
            input.MoveInput = command.MoveInput;
            input.AttackPressed = command.AttackPressed;
            input.JumpPressed = command.JumpPressed;
            
            // 发布输入事件
            await PublishEventAsync(new PlayerInputEvent
            {
                CorrelationId = command.CommandId,
                PlayerId = command.PlayerId,
                MoveInput = command.MoveInput,
                AttackPressed = command.AttackPressed,
                JumpPressed = command.JumpPressed
            });
        }
    }
}
```

## 节点层集成

### 1. 游戏节点基类

```csharp
// 游戏实体节点基类
public abstract partial class GameEntityNode : MediatorEventNode<Node2D>
{
    [Export] public uint EntityId { get; set; }
    
    protected IEntityManager EntityManager { get; private set; }
    
    public override void _Ready()
    {
        EntityManager = GetService<IEntityManager>();
        base._Ready();
    }
    
    protected override void SubscribeToEvents()
    {
        // 订阅实体相关事件
        Subscribe<EntityMovedEvent>(
            evt => evt.EntityId == EntityId,
            HandleEntityMoved
        );
        
        Subscribe<StateChangedEvent>(
            evt => evt.EntityId == EntityId,
            HandleStateChanged
        );
        
        Subscribe<ComponentAddedEvent<RenderComponent>>(
            evt => evt.EntityId == EntityId,
            HandleRenderComponentAdded
        );
    }
    
    private async Task HandleEntityMoved(EntityMovedEvent evt)
    {
        // 更新节点位置
        GlobalPosition = evt.NewPosition;
        
        // 更新朝向
        if (evt.Velocity.X != 0)
        {
            Scale = new Vector2(evt.Velocity.X > 0 ? 1 : -1, 1);
        }
    }
    
    private async Task HandleStateChanged(StateChangedEvent evt)
    {
        // 根据状态变化更新动画
        await UpdateAnimationForState(evt.NewState);
    }
    
    private async Task HandleRenderComponentAdded(ComponentAddedEvent<RenderComponent> evt)
    {
        // 更新渲染属性
        var renderComponent = evt.Component;
        
        if (GetNode("Sprite2D") is Sprite2D sprite)
        {
            sprite.Texture = GD.Load<Texture2D>(renderComponent.SpritePath);
            sprite.Modulate = renderComponent.Tint;
            sprite.Scale = renderComponent.Scale;
            sprite.ZIndex = renderComponent.ZIndex;
        }
    }
    
    protected virtual async Task UpdateAnimationForState(string state)
    {
        if (GetNode("AnimationPlayer") is AnimationPlayer animationPlayer)
        {
            var animationName = state.ToLower();
            if (animationPlayer.HasAnimation(animationName))
            {
                animationPlayer.Play(animationName);
            }
        }
    }
}
```

### 2. 玩家节点实现

```csharp
public partial class PlayerNode : GameEntityNode
{
    public override void _Input(InputEvent @event)
    {
        // 收集输入并发送命令
        var moveInput = Vector2.Zero;
        var attackPressed = false;
        var jumpPressed = false;
        
        if (Input.IsActionPressed("move_left")) moveInput.X -= 1;
        if (Input.IsActionPressed("move_right")) moveInput.X += 1;
        if (Input.IsActionPressed("move_up")) moveInput.Y -= 1;
        if (Input.IsActionPressed("move_down")) moveInput.Y += 1;
        
        attackPressed = Input.IsActionJustPressed("attack");
        jumpPressed = Input.IsActionJustPressed("jump");
        
        // 只有输入变化时才发送命令
        if (ShouldSendInputCommand(moveInput, attackPressed, jumpPressed))
        {
            _ = SendCommandAsync(new PlayerInputCommand(EntityId, moveInput, attackPressed, jumpPressed));
        }
    }
    
    private bool ShouldSendInputCommand(Vector2 moveInput, bool attackPressed, bool jumpPressed)
    {
        // 简单的输入变化检测逻辑
        return attackPressed || jumpPressed || moveInput != Vector2.Zero;
    }
    
    protected override void SubscribeToEvents()
    {
        base.SubscribeToEvents();
        
        // 订阅玩家特有事件
        Subscribe<AttackExecutedEvent>(
            evt => evt.AttackerId == EntityId,
            HandleAttackExecuted
        );
    }
    
    private async Task HandleAttackExecuted(AttackExecutedEvent evt)
    {
        // 播放攻击特效
        await PlayAttackEffect(evt.Position, evt.AttackType);
    }
    
    private async Task PlayAttackEffect(Vector2 position, string attackType)
    {
        // 创建攻击特效
        var effectScene = GD.Load<PackedScene>("res://effects/AttackEffect.tscn");
        var effect = effectScene.Instantiate<Node2D>();
        GetParent().AddChild(effect);
        effect.GlobalPosition = position;
        
        // 播放特效动画
        if (effect.GetNode("AnimationPlayer") is AnimationPlayer animationPlayer)
        {
            animationPlayer.Play(attackType.ToLower());
            
            // 动画播放完毕后销毁特效
            await ToSignal(animationPlayer, AnimationPlayer.SignalName.AnimationFinished);
            effect.QueueFree();
        }
    }
}
```

## 总结

通过这种架构设计，我们成功地解决了游戏逻辑边界划分的问题：

### 1. 清晰的职责分离
- **ECS系统**：处理纯逻辑（状态机、AI、物理）
- **节点层**：处理表现（渲染、动画、特效、输入）
- **命令/事件**：作为两层之间的通信桥梁

### 2. 状态机与架构的完美集成
- 状态机作为ECS组件存在
- 状态转换通过事件通知节点层
- 节点层根据状态变化更新表现

### 3. AI系统的模块化设计
- 行为树与ECS系统集成
- AI决策通过命令执行
- 决策结果通过事件反馈

### 4. 性能与架构的平衡
- 热路径（移动、AI更新）在ECS系统中高效执行
- 冷路径（UI交互、配置）通过CQRS处理
- 表现层异步响应逻辑层变化

这种架构既保持了代码的清晰性和可维护性，又满足了游戏开发的性能要求，是游戏架构设计的最佳实践。