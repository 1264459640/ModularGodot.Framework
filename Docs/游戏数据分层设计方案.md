# 游戏数据分层设计方案

## 问题分析

你提出了一个很好的架构组织问题：**游戏逻辑的数据是否可以放在数据访问层 `MF.Data`？**

答案是**可以，但需要合理分层和组织**。基于我们之前讨论的ECS架构和CQRS模式，游戏数据应该按照不同的职责和生命周期进行分层管理。

## 当前MF.Data结构分析

从现有代码可以看到，`MF.Data` 目前包含：

1. **属性集数据库系统**：玩家属性、效果、修饰器等
2. **用户设置序列化**：游戏设置、控制设置、音频设置等

这是一个良好的开始，但需要扩展以支持完整的游戏数据架构。

## 游戏数据分层设计

### 1. 数据分类原则

按照**数据特性**和**生命周期**进行分类：

```
游戏数据
├── 瞬态数据 (Transient Data)
│   ├── ECS组件数据 (运行时)
│   ├── 游戏状态数据 (会话期间)
│   └── 缓存数据 (临时存储)
├── 持久化数据 (Persistent Data)
│   ├── 玩家档案数据 (长期存储)
│   ├── 游戏进度数据 (存档系统)
│   └── 统计数据 (分析用途)
├── 配置数据 (Configuration Data)
│   ├── 游戏设置 (用户偏好)
│   ├── 系统配置 (框架配置)
│   └── 资源配置 (资产管理)
└── 静态数据 (Static Data)
    ├── 游戏规则数据 (设计数据)
    ├── 本地化数据 (多语言)
    └── 资源元数据 (资产信息)
```

### 2. MF.Data重新组织结构

```
MF.Data/
├── Core/                           # 核心数据基础设施
│   ├── Interfaces/
│   │   ├── IRepository.cs          # 仓储基接口
│   │   ├── IDataContext.cs         # 数据上下文接口
│   │   └── ISerializer.cs          # 序列化接口
│   ├── Base/
│   │   ├── BaseRepository.cs       # 仓储基类
│   │   ├── BaseEntity.cs           # 实体基类
│   │   └── DataContextBase.cs      # 数据上下文基类
│   └── Attributes/
│       ├── TableAttribute.cs       # 表映射属性
│       └── ComponentAttribute.cs   # 组件标记属性
├── Transient/                      # 瞬态数据
│   ├── Components/                 # ECS组件数据
│   │   ├── IComponent.cs           # 组件接口
│   │   ├── PositionComponent.cs    # 位置组件
│   │   ├── MovementComponent.cs    # 移动组件
│   │   ├── HealthComponent.cs      # 生命值组件
│   │   ├── CombatComponent.cs      # 战斗组件
│   │   └── AIComponent.cs          # AI组件
│   ├── GameState/                  # 游戏状态数据
│   │   ├── GameSession.cs          # 游戏会话
│   │   ├── SceneState.cs           # 场景状态
│   │   └── PlayerState.cs          # 玩家状态
│   └── Cache/                      # 缓存数据
│       ├── EntityCache.cs          # 实体缓存
│       ├── ResourceCache.cs        # 资源缓存
│       └── QueryCache.cs           # 查询缓存
├── Persistent/                     # 持久化数据
│   ├── Player/                     # 玩家数据
│   │   ├── Models/
│   │   │   ├── PlayerProfile.cs    # 玩家档案
│   │   │   ├── PlayerProgress.cs   # 游戏进度
│   │   │   └── PlayerStatistics.cs # 玩家统计
│   │   ├── Repositories/
│   │   │   ├── IPlayerRepository.cs
│   │   │   └── PlayerRepository.cs
│   │   └── Context/
│   │       └── PlayerDbContext.cs  # 玩家数据库上下文
│   ├── Game/                       # 游戏数据
│   │   ├── Models/
│   │   │   ├── SaveGame.cs         # 存档数据
│   │   │   ├── GameWorld.cs        # 游戏世界
│   │   │   └── Quest.cs            # 任务数据
│   │   ├── Repositories/
│   │   │   ├── ISaveGameRepository.cs
│   │   │   └── SaveGameRepository.cs
│   │   └── Context/
│   │       └── GameDbContext.cs    # 游戏数据库上下文
│   └── Analytics/                  # 分析数据
│       ├── Models/
│       │   ├── GameEvent.cs        # 游戏事件
│       │   └── PerformanceMetric.cs # 性能指标
│       └── Repositories/
│           └── AnalyticsRepository.cs
├── Configuration/                  # 配置数据
│   ├── Settings/                   # 设置数据
│   │   ├── UserSettings.cs         # 用户设置 (已存在)
│   │   ├── GameSettings.cs         # 游戏设置
│   │   └── SystemSettings.cs       # 系统设置
│   ├── Framework/                  # 框架配置
│   │   ├── ECSConfig.cs            # ECS配置
│   │   ├── EventBusConfig.cs       # 事件总线配置
│   │   └── PerformanceConfig.cs    # 性能配置
│   └── Resources/                  # 资源配置
│       ├── AssetManifest.cs        # 资产清单
│       └── LocalizationConfig.cs  # 本地化配置
├── Static/                         # 静态数据
│   ├── GameDesign/                 # 游戏设计数据
│   │   ├── ItemData.cs             # 物品数据
│   │   ├── SkillData.cs            # 技能数据
│   │   └── EnemyData.cs            # 敌人数据
│   ├── Localization/               # 本地化数据
│   │   ├── LocalizationKey.cs      # 本地化键
│   │   └── LanguageData.cs         # 语言数据
│   └── Assets/                     # 资产元数据
│       ├── TextureMetadata.cs      # 纹理元数据
│       └── AudioMetadata.cs        # 音频元数据
└── Serialization/                  # 序列化支持
    ├── Json/
    │   ├── JsonSerializer.cs       # JSON序列化器
    │   └── JsonConverters.cs       # JSON转换器
    ├── Binary/
    │   ├── BinarySerializer.cs     # 二进制序列化器
    │   └── CompressionHelper.cs    # 压缩辅助
    └── Database/
        ├── EntityFrameworkContext.cs # EF上下文
        └── SQLiteProvider.cs       # SQLite提供者
```

## 具体实现方案

### 1. ECS组件数据结构

```csharp
// MF.Data/Transient/Components/IComponent.cs
namespace MF.Data.Transient.Components
{
    /// <summary>
    /// ECS组件基接口
    /// </summary>
    public interface IComponent
    {
        /// <summary>
        /// 组件类型ID
        /// </summary>
        int ComponentTypeId { get; }
        
        /// <summary>
        /// 组件是否有效
        /// </summary>
        bool IsValid { get; }
        
        /// <summary>
        /// 重置组件到默认状态
        /// </summary>
        void Reset();
        
        /// <summary>
        /// 复制组件数据
        /// </summary>
        IComponent Clone();
    }
    
    /// <summary>
    /// 组件基类
    /// </summary>
    public abstract class ComponentBase : IComponent
    {
        public abstract int ComponentTypeId { get; }
        public virtual bool IsValid => true;
        
        public virtual void Reset() { }
        public abstract IComponent Clone();
    }
}

// MF.Data/Transient/Components/PositionComponent.cs
using System.Numerics;
using Newtonsoft.Json;

namespace MF.Data.Transient.Components
{
    /// <summary>
    /// 位置组件
    /// </summary>
    [Serializable]
    [Component("Position")]
    public struct PositionComponent : IComponent
    {
        public int ComponentTypeId => ComponentTypes.Position;
        public bool IsValid => true;
        
        [JsonProperty("position")]
        public Vector2 Position;
        
        [JsonProperty("rotation")]
        public float Rotation;
        
        [JsonProperty("scale")]
        public Vector2 Scale;
        
        public PositionComponent(Vector2 position, float rotation = 0f, Vector2? scale = null)
        {
            Position = position;
            Rotation = rotation;
            Scale = scale ?? Vector2.One;
        }
        
        public void Reset()
        {
            Position = Vector2.Zero;
            Rotation = 0f;
            Scale = Vector2.One;
        }
        
        public IComponent Clone()
        {
            return new PositionComponent(Position, Rotation, Scale);
        }
    }
}

// MF.Data/Transient/Components/MovementComponent.cs
namespace MF.Data.Transient.Components
{
    /// <summary>
    /// 移动组件
    /// </summary>
    [Serializable]
    [Component("Movement")]
    public struct MovementComponent : IComponent
    {
        public int ComponentTypeId => ComponentTypes.Movement;
        public bool IsValid => Speed > 0;
        
        [JsonProperty("velocity")]
        public Vector2 Velocity;
        
        [JsonProperty("speed")]
        public float Speed;
        
        [JsonProperty("direction")]
        public Vector2 Direction;
        
        [JsonProperty("acceleration")]
        public float Acceleration;
        
        [JsonProperty("friction")]
        public float Friction;
        
        public MovementComponent(float speed, float acceleration = 1000f, float friction = 500f)
        {
            Speed = speed;
            Acceleration = acceleration;
            Friction = friction;
            Velocity = Vector2.Zero;
            Direction = Vector2.Zero;
        }
        
        public void Reset()
        {
            Velocity = Vector2.Zero;
            Direction = Vector2.Zero;
        }
        
        public IComponent Clone()
        {
            return new MovementComponent(Speed, Acceleration, Friction)
            {
                Velocity = Velocity,
                Direction = Direction
            };
        }
    }
}

// MF.Data/Transient/Components/ComponentTypes.cs
namespace MF.Data.Transient.Components
{
    /// <summary>
    /// 组件类型常量
    /// </summary>
    public static class ComponentTypes
    {
        public const int Position = 1;
        public const int Movement = 2;
        public const int Health = 3;
        public const int Combat = 4;
        public const int AI = 5;
        public const int Render = 6;
        public const int Animation = 7;
        public const int Audio = 8;
        public const int Input = 9;
        public const int UI = 10;
        
        // 扩展组件类型从100开始
        public const int CustomStart = 100;
    }
}
```

### 2. 游戏状态数据结构

```csharp
// MF.Data/Transient/GameState/GameSession.cs
namespace MF.Data.Transient.GameState
{
    /// <summary>
    /// 游戏会话数据
    /// </summary>
    [Serializable]
    public class GameSession
    {
        [JsonProperty("session_id")]
        public string SessionId { get; set; } = Guid.NewGuid().ToString();
        
        [JsonProperty("start_time")]
        public DateTime StartTime { get; set; } = DateTime.Now;
        
        [JsonProperty("current_scene")]
        public string CurrentScene { get; set; } = "MainMenu";
        
        [JsonProperty("game_state")]
        public string GameState { get; set; } = "Menu";
        
        [JsonProperty("player_count")]
        public int PlayerCount { get; set; } = 1;
        
        [JsonProperty("session_data")]
        public Dictionary<string, object> SessionData { get; set; } = new();
        
        [JsonProperty("performance_stats")]
        public PerformanceStats Performance { get; set; } = new();
    }
    
    /// <summary>
    /// 性能统计数据
    /// </summary>
    [Serializable]
    public class PerformanceStats
    {
        [JsonProperty("fps")]
        public float AverageFPS { get; set; }
        
        [JsonProperty("frame_time")]
        public float AverageFrameTime { get; set; }
        
        [JsonProperty("memory_usage")]
        public long MemoryUsage { get; set; }
        
        [JsonProperty("entity_count")]
        public int EntityCount { get; set; }
        
        [JsonProperty("system_count")]
        public int SystemCount { get; set; }
    }
}

// MF.Data/Transient/GameState/PlayerState.cs
namespace MF.Data.Transient.GameState
{
    /// <summary>
    /// 玩家运行时状态
    /// </summary>
    [Serializable]
    public class PlayerState
    {
        [JsonProperty("player_id")]
        public string PlayerId { get; set; }
        
        [JsonProperty("entity_id")]
        public uint EntityId { get; set; }
        
        [JsonProperty("current_health")]
        public float CurrentHealth { get; set; }
        
        [JsonProperty("max_health")]
        public float MaxHealth { get; set; }
        
        [JsonProperty("current_energy")]
        public float CurrentEnergy { get; set; }
        
        [JsonProperty("max_energy")]
        public float MaxEnergy { get; set; }
        
        [JsonProperty("position")]
        public Vector2 Position { get; set; }
        
        [JsonProperty("level")]
        public int Level { get; set; }
        
        [JsonProperty("experience")]
        public int Experience { get; set; }
        
        [JsonProperty("inventory")]
        public List<InventoryItem> Inventory { get; set; } = new();
        
        [JsonProperty("active_effects")]
        public List<ActiveEffect> ActiveEffects { get; set; } = new();
        
        [JsonProperty("input_state")]
        public InputState InputState { get; set; } = new();
    }
    
    /// <summary>
    /// 库存物品
    /// </summary>
    [Serializable]
    public class InventoryItem
    {
        [JsonProperty("item_id")]
        public string ItemId { get; set; }
        
        [JsonProperty("quantity")]
        public int Quantity { get; set; }
        
        [JsonProperty("slot_index")]
        public int SlotIndex { get; set; }
    }
    
    /// <summary>
    /// 激活效果
    /// </summary>
    [Serializable]
    public class ActiveEffect
    {
        [JsonProperty("effect_id")]
        public string EffectId { get; set; }
        
        [JsonProperty("remaining_time")]
        public float RemainingTime { get; set; }
        
        [JsonProperty("stack_count")]
        public int StackCount { get; set; }
    }
    
    /// <summary>
    /// 输入状态
    /// </summary>
    [Serializable]
    public class InputState
    {
        [JsonProperty("move_input")]
        public Vector2 MoveInput { get; set; }
        
        [JsonProperty("attack_pressed")]
        public bool AttackPressed { get; set; }
        
        [JsonProperty("jump_pressed")]
        public bool JumpPressed { get; set; }
        
        [JsonProperty("interact_pressed")]
        public bool InteractPressed { get; set; }
    }
}
```

### 3. 持久化数据结构

```csharp
// MF.Data/Persistent/Player/Models/PlayerProfile.cs
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace MF.Data.Persistent.Player.Models
{
    /// <summary>
    /// 玩家档案数据
    /// </summary>
    [Table("PlayerProfiles")]
    public class PlayerProfile
    {
        [Key]
        [Column("player_id")]
        public string PlayerId { get; set; } = Guid.NewGuid().ToString();
        
        [Required]
        [MaxLength(50)]
        [Column("player_name")]
        public string PlayerName { get; set; }
        
        [Column("created_at")]
        public DateTime CreatedAt { get; set; } = DateTime.Now;
        
        [Column("last_login")]
        public DateTime LastLogin { get; set; } = DateTime.Now;
        
        [Column("total_play_time")]
        public TimeSpan TotalPlayTime { get; set; }
        
        [Column("player_level")]
        public int PlayerLevel { get; set; } = 1;
        
        [Column("total_experience")]
        public long TotalExperience { get; set; }
        
        [Column("avatar_id")]
        public string AvatarId { get; set; }
        
        [Column("settings_json")]
        public string SettingsJson { get; set; } = "{}";
        
        // 导航属性
        public virtual ICollection<PlayerProgress> ProgressRecords { get; set; } = new List<PlayerProgress>();
        public virtual ICollection<PlayerStatistics> Statistics { get; set; } = new List<PlayerStatistics>();
    }
}

// MF.Data/Persistent/Game/Models/SaveGame.cs
namespace MF.Data.Persistent.Game.Models
{
    /// <summary>
    /// 游戏存档数据
    /// </summary>
    [Table("SaveGames")]
    public class SaveGame
    {
        [Key]
        [Column("save_id")]
        public string SaveId { get; set; } = Guid.NewGuid().ToString();
        
        [Required]
        [Column("player_id")]
        public string PlayerId { get; set; }
        
        [Required]
        [MaxLength(100)]
        [Column("save_name")]
        public string SaveName { get; set; }
        
        [Column("created_at")]
        public DateTime CreatedAt { get; set; } = DateTime.Now;
        
        [Column("updated_at")]
        public DateTime UpdatedAt { get; set; } = DateTime.Now;
        
        [Column("game_version")]
        public string GameVersion { get; set; }
        
        [Column("current_scene")]
        public string CurrentScene { get; set; }
        
        [Column("play_time")]
        public TimeSpan PlayTime { get; set; }
        
        [Column("game_data_json")]
        public string GameDataJson { get; set; } = "{}";
        
        [Column("world_state_json")]
        public string WorldStateJson { get; set; } = "{}";
        
        [Column("player_state_json")]
        public string PlayerStateJson { get; set; } = "{}";
        
        [Column("screenshot_path")]
        public string ScreenshotPath { get; set; }
        
        [Column("is_auto_save")]
        public bool IsAutoSave { get; set; }
        
        [Column("save_size_bytes")]
        public long SaveSizeBytes { get; set; }
    }
}
```

### 4. 配置数据扩展

```csharp
// MF.Data/Configuration/Framework/ECSConfig.cs
namespace MF.Data.Configuration.Framework
{
    /// <summary>
    /// ECS系统配置
    /// </summary>
    [Serializable]
    public class ECSConfig
    {
        [JsonProperty("max_entities")]
        public int MaxEntities { get; set; } = 100000;
        
        [JsonProperty("component_pool_size")]
        public int ComponentPoolSize { get; set; } = 1000;
        
        [JsonProperty("system_update_order")]
        public List<string> SystemUpdateOrder { get; set; } = new()
        {
            "InputSystem",
            "AISystem",
            "MovementSystem",
            "PhysicsSystem",
            "CombatSystem",
            "AnimationSystem",
            "RenderSystem",
            "AudioSystem",
            "UISystem"
        };
        
        [JsonProperty("performance_monitoring")]
        public bool PerformanceMonitoring { get; set; } = true;
        
        [JsonProperty("component_serialization")]
        public bool ComponentSerialization { get; set; } = true;
        
        [JsonProperty("entity_debugging")]
        public bool EntityDebugging { get; set; } = false;
    }
}

// MF.Data/Configuration/Framework/PerformanceConfig.cs
namespace MF.Data.Configuration.Framework
{
    /// <summary>
    /// 性能配置
    /// </summary>
    [Serializable]
    public class PerformanceConfig
    {
        [JsonProperty("target_fps")]
        public int TargetFPS { get; set; } = 60;
        
        [JsonProperty("vsync_enabled")]
        public bool VsyncEnabled { get; set; } = true;
        
        [JsonProperty("performance_mode")]
        public string PerformanceMode { get; set; } = "Balanced"; // "Performance", "Balanced", "Quality"
        
        [JsonProperty("node_access_level")]
        public Dictionary<string, string> NodeAccessLevel { get; set; } = new()
        {
            { "MovementSystem", "Critical" },
            { "AnimationSystem", "Critical" },
            { "PhysicsSystem", "Critical" },
            { "UISystem", "Standard" },
            { "AudioSystem", "Standard" },
            { "DebugSystem", "Flexible" }
        };
        
        [JsonProperty("batch_processing")]
        public bool BatchProcessing { get; set; } = true;
        
        [JsonProperty("object_pooling")]
        public bool ObjectPooling { get; set; } = true;
        
        [JsonProperty("memory_monitoring")]
        public bool MemoryMonitoring { get; set; } = true;
    }
}
```

### 5. 静态数据结构

```csharp
// MF.Data/Static/GameDesign/ItemData.cs
namespace MF.Data.Static.GameDesign
{
    /// <summary>
    /// 物品设计数据
    /// </summary>
    [Serializable]
    public class ItemData
    {
        [JsonProperty("item_id")]
        public string ItemId { get; set; }
        
        [JsonProperty("item_name")]
        public string ItemName { get; set; }
        
        [JsonProperty("item_type")]
        public string ItemType { get; set; }
        
        [JsonProperty("rarity")]
        public string Rarity { get; set; }
        
        [JsonProperty("max_stack")]
        public int MaxStack { get; set; } = 1;
        
        [JsonProperty("base_value")]
        public int BaseValue { get; set; }
        
        [JsonProperty("icon_path")]
        public string IconPath { get; set; }
        
        [JsonProperty("description_key")]
        public string DescriptionKey { get; set; }
        
        [JsonProperty("properties")]
        public Dictionary<string, object> Properties { get; set; } = new();
        
        [JsonProperty("effects")]
        public List<ItemEffect> Effects { get; set; } = new();
    }
    
    /// <summary>
    /// 物品效果
    /// </summary>
    [Serializable]
    public class ItemEffect
    {
        [JsonProperty("effect_type")]
        public string EffectType { get; set; }
        
        [JsonProperty("effect_value")]
        public float EffectValue { get; set; }
        
        [JsonProperty("duration")]
        public float Duration { get; set; }
        
        [JsonProperty("target")]
        public string Target { get; set; }
    }
}
```

## 数据访问层集成

### 1. 统一仓储接口

```csharp
// MF.Data/Core/Interfaces/IRepository.cs
namespace MF.Data.Core.Interfaces
{
    /// <summary>
    /// 通用仓储接口
    /// </summary>
    public interface IRepository<T, TKey> where T : class
    {
        Task<T> GetByIdAsync(TKey id);
        Task<IEnumerable<T>> GetAllAsync();
        Task<IEnumerable<T>> FindAsync(Expression<Func<T, bool>> predicate);
        Task<T> AddAsync(T entity);
        Task<T> UpdateAsync(T entity);
        Task<bool> DeleteAsync(TKey id);
        Task<int> SaveChangesAsync();
    }
    
    /// <summary>
    /// ECS组件仓储接口
    /// </summary>
    public interface IComponentRepository
    {
        Task<T> GetComponentAsync<T>(uint entityId) where T : IComponent;
        Task<bool> HasComponentAsync<T>(uint entityId) where T : IComponent;
        Task AddComponentAsync<T>(uint entityId, T component) where T : IComponent;
        Task RemoveComponentAsync<T>(uint entityId) where T : IComponent;
        Task<IEnumerable<uint>> GetEntitiesWithAsync<T>() where T : IComponent;
        Task<IEnumerable<uint>> GetEntitiesWithAsync(params Type[] componentTypes);
    }
    
    /// <summary>
    /// 游戏状态仓储接口
    /// </summary>
    public interface IGameStateRepository
    {
        Task<GameSession> GetCurrentSessionAsync();
        Task SaveSessionAsync(GameSession session);
        Task<PlayerState> GetPlayerStateAsync(string playerId);
        Task SavePlayerStateAsync(PlayerState playerState);
        Task<SceneState> GetSceneStateAsync(string sceneName);
        Task SaveSceneStateAsync(SceneState sceneState);
    }
}
```

### 2. 数据上下文管理

```csharp
// MF.Data/Core/DataContextManager.cs
namespace MF.Data.Core
{
    /// <summary>
    /// 数据上下文管理器
    /// </summary>
    public class DataContextManager : IDisposable
    {
        private readonly Dictionary<Type, IDataContext> _contexts = new();
        private readonly IServiceProvider _serviceProvider;
        
        public DataContextManager(IServiceProvider serviceProvider)
        {
            _serviceProvider = serviceProvider;
        }
        
        public T GetContext<T>() where T : class, IDataContext
        {
            var contextType = typeof(T);
            
            if (!_contexts.TryGetValue(contextType, out var context))
            {
                context = _serviceProvider.GetRequiredService<T>();
                _contexts[contextType] = context;
            }
            
            return (T)context;
        }
        
        public async Task SaveAllChangesAsync()
        {
            var tasks = _contexts.Values.Select(context => context.SaveChangesAsync());
            await Task.WhenAll(tasks);
        }
        
        public void Dispose()
        {
            foreach (var context in _contexts.Values)
            {
                context?.Dispose();
            }
            _contexts.Clear();
        }
    }
}
```

## 与ECS系统集成

### 1. 组件数据同步

```csharp
// MF.Data/Integration/ECSDataSync.cs
namespace MF.Data.Integration
{
    /// <summary>
    /// ECS数据同步服务
    /// </summary>
    public class ECSDataSync : IECSDataSync
    {
        private readonly IComponentRepository _componentRepository;
        private readonly IGameStateRepository _gameStateRepository;
        private readonly IEventBus _eventBus;
        
        public ECSDataSync(
            IComponentRepository componentRepository,
            IGameStateRepository gameStateRepository,
            IEventBus eventBus)
        {
            _componentRepository = componentRepository;
            _gameStateRepository = gameStateRepository;
            _eventBus = eventBus;
            
            // 订阅ECS事件
            _eventBus.Subscribe<ComponentAddedEvent>(OnComponentAdded);
            _eventBus.Subscribe<ComponentRemovedEvent>(OnComponentRemoved);
            _eventBus.Subscribe<ComponentChangedEvent>(OnComponentChanged);
        }
        
        public async Task SyncComponentToDataAsync<T>(uint entityId, T component) where T : IComponent
        {
            await _componentRepository.AddComponentAsync(entityId, component);
        }
        
        public async Task<T> LoadComponentFromDataAsync<T>(uint entityId) where T : IComponent
        {
            return await _componentRepository.GetComponentAsync<T>(entityId);
        }
        
        public async Task SyncGameStateAsync(GameSession session)
        {
            await _gameStateRepository.SaveSessionAsync(session);
        }
        
        private async Task OnComponentAdded(ComponentAddedEvent evt)
        {
            // 自动同步新增组件到数据层
            if (evt.ShouldPersist)
            {
                await SyncComponentToDataAsync(evt.EntityId, evt.Component);
            }
        }
        
        private async Task OnComponentRemoved(ComponentRemovedEvent evt)
        {
            // 从数据层移除组件
            await _componentRepository.RemoveComponentAsync<IComponent>(evt.EntityId);
        }
        
        private async Task OnComponentChanged(ComponentChangedEvent evt)
        {
            // 更新数据层中的组件
            if (evt.ShouldPersist)
            {
                await SyncComponentToDataAsync(evt.EntityId, evt.Component);
            }
        }
    }
}
```

## 性能优化策略

### 1. 数据分层缓存

```csharp
// MF.Data/Core/Caching/DataCacheManager.cs
namespace MF.Data.Core.Caching
{
    /// <summary>
    /// 数据缓存管理器
    /// </summary>
    public class DataCacheManager : IDataCacheManager
    {
        private readonly IMemoryCache _memoryCache;
        private readonly IDistributedCache _distributedCache;
        private readonly ILogger<DataCacheManager> _logger;
        
        // 不同数据类型的缓存策略
        private readonly Dictionary<Type, CachePolicy> _cachePolicies = new()
        {
            { typeof(IComponent), new CachePolicy { Duration = TimeSpan.FromMinutes(5), Priority = CachePriority.High } },
            { typeof(PlayerState), new CachePolicy { Duration = TimeSpan.FromMinutes(10), Priority = CachePriority.High } },
            { typeof(GameSession), new CachePolicy { Duration = TimeSpan.FromMinutes(30), Priority = CachePriority.Medium } },
            { typeof(ItemData), new CachePolicy { Duration = TimeSpan.FromHours(1), Priority = CachePriority.Low } },
            { typeof(UserSettings), new CachePolicy { Duration = TimeSpan.FromHours(24), Priority = CachePriority.Low } }
        };
        
        public async Task<T> GetOrSetAsync<T>(string key, Func<Task<T>> factory) where T : class
        {
            // 先尝试从内存缓存获取
            if (_memoryCache.TryGetValue(key, out T cachedValue))
            {
                return cachedValue;
            }
            
            // 再尝试从分布式缓存获取
            var distributedValue = await _distributedCache.GetStringAsync(key);
            if (!string.IsNullOrEmpty(distributedValue))
            {
                var deserializedValue = JsonConvert.DeserializeObject<T>(distributedValue);
                
                // 回写到内存缓存
                var policy = GetCachePolicy<T>();
                _memoryCache.Set(key, deserializedValue, policy.Duration);
                
                return deserializedValue;
            }
            
            // 缓存未命中，执行工厂方法
            var value = await factory();
            if (value != null)
            {
                await SetAsync(key, value);
            }
            
            return value;
        }
        
        public async Task SetAsync<T>(string key, T value) where T : class
        {
            var policy = GetCachePolicy<T>();
            
            // 设置内存缓存
            _memoryCache.Set(key, value, new MemoryCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = policy.Duration,
                Priority = policy.Priority
            });
            
            // 设置分布式缓存
            var serializedValue = JsonConvert.SerializeObject(value);
            await _distributedCache.SetStringAsync(key, serializedValue, new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = policy.Duration
            });
        }
        
        private CachePolicy GetCachePolicy<T>()
        {
            var type = typeof(T);
            
            // 查找最匹配的缓存策略
            foreach (var kvp in _cachePolicies)
            {
                if (kvp.Key.IsAssignableFrom(type))
                {
                    return kvp.Value;
                }
            }
            
            // 默认缓存策略
            return new CachePolicy { Duration = TimeSpan.FromMinutes(5), Priority = CachePriority.Normal };
        }
    }
    
    public class CachePolicy
    {
        public TimeSpan Duration { get; set; }
        public CachePriority Priority { get; set; }
    }
}
```

## 总结

**游戏逻辑的数据完全可以放在 `MF.Data` 数据访问层**，但需要按照以下原则进行组织：

### 1. 分层原则
- **瞬态数据**：ECS组件、游戏状态、缓存数据
- **持久化数据**：玩家档案、存档、统计数据
- **配置数据**：设置、框架配置、资源配置
- **静态数据**：游戏设计数据、本地化、资产元数据

### 2. 性能考虑
- **热数据**：使用内存缓存和对象池
- **温数据**：使用分层缓存策略
- **冷数据**：直接从持久化存储读取

### 3. 架构集成
- **ECS集成**：组件数据自动同步
- **CQRS集成**：命令和事件驱动数据变更
- **服务层集成**：通过仓储模式访问数据

### 4. 扩展性
- **插件支持**：数据结构支持扩展
- **多后端支持**：抽象数据访问接口
- **版本兼容**：数据迁移和版本管理

这种设计既保持了数据的组织性和可维护性，又支持了游戏开发的性能要求和扩展需求。