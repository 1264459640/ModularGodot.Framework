# 仓储层模块迁移方案

## 问题分析

你提出了一个非常准确的架构重构问题！基于我们之前制定的 <mcfile name="仓储层职责重构方案.md" path="d:\GodotProjects\ModularGodot\仓储层职责重构方案.md"></mcfile>，以下三个模块确实**不应该**放在仓储层中：

- `EventBus` - 事件总线系统
- `LogSystem` - 日志系统
- `ResourceSystem` - 资源系统

这些模块违反了仓储层的职责边界，应该迁移到更合适的层次。

## 当前问题分析

### 1. EventBus模块错误归属

```csharp
// 当前位置：MF.Repositories.Core.EventBus.EventBusRepo
// ❌ 问题：事件总线不是数据访问逻辑
public class EventBusRepo: BaseRepo,IEventBusRepo
{
    private readonly Dictionary<Type, Subject<object>> _subjects = new();
    private readonly CompositeDisposable _disposables = new();

    public void Publish<TEvent>(TEvent @event) where TEvent : IEvent
    {
        // 这是基础设施服务，不是数据仓储
        var eventType = typeof(TEvent);
        if (!_subjects.TryGetValue(eventType, out var subject))
        {
            subject = new Subject<object>();
            _subjects[eventType] = subject;
        }
        subject.OnNext(@event);
    }
}
```

**问题**：
- 事件总线是**基础设施服务**，不是数据访问
- 它提供跨模块通信能力，属于横切关注点
- 应该被其他层（包括仓储层）使用，而不是属于仓储层

### 2. LogSystem模块错误归属

```csharp
// 当前位置：MF.Repositories.Core.LogSystem.LoggerRepo
// ❌ 问题：日志系统不是数据仓储
public class LoggerRepo : ILoggerRepo
{
    private LogLevel _currentLevel = LogLevel.Debug;
    private bool _enableFileLogging = false;
    private string _logFilePath = "user://logs/game.log";
    private FileAccess? _logFile;
    
    public void SetLevel(LogLevel level)
    {
        // 这是基础设施服务，不是数据仓储
        _currentLevel = level;
    }
}
```

**问题**：
- 日志系统是**基础设施服务**，不是业务数据访问
- 它是横切关注点，应该被所有层使用
- 虽然涉及文件操作，但不是业务数据的CRUD

### 3. ResourceSystem模块职责混乱

```csharp
// 当前位置：MF.Repositories.Core.ResourceSystem
// ❌ 问题：资源系统包含了太多非仓储职责

// 这些是基础设施服务，不是仓储职责：
- CacheManager.cs        // 缓存管理
- MemoryMonitor.cs       // 内存监控
- ReferenceTracker.cs    // 引用跟踪
- StatsCollector.cs      // 统计收集
- SizeCalculator.cs      // 大小计算

// 这些可能是仓储职责：
- ResourceLoaderRepo.cs  // 资源加载（但实现方式有问题）
- IResourceLoader.cs     // 资源加载接口
```

**问题**：
- 大部分组件是**技术实现细节**，不是业务数据访问
- 缓存、监控、统计都是基础设施关注点
- 只有资源的加载/获取才是仓储职责

## 迁移方案设计

### 1. 目标架构重新规划

```
当前错误架构：
MF.Repositories/
├── Core/
│   ├── EventBus/     ❌ 应该是基础设施服务
│   ├── LogSystem/    ❌ 应该是基础设施服务
│   └── ResourceSystem/ ❌ 大部分应该是基础设施服务

目标正确架构：
MF.Services/              ✅ 服务层（业务逻辑）
├── ResourceService/      ✅ 资源管理服务
└── ...

MF.Infrastructure/        ✅ 基础设施层（技术服务）
├── EventBus/            ✅ 事件总线基础设施
├── Logging/             ✅ 日志基础设施
├── Caching/             ✅ 缓存基础设施
├── Monitoring/          ✅ 监控基础设施
└── ResourceLoading/     ✅ 资源加载基础设施

MF.Repositories/         ✅ 仓储层（数据访问）
├── ResourceRepository/  ✅ 资源数据访问
├── PlayerRepository/    ✅ 玩家数据访问
└── GameDataRepository/  ✅ 游戏数据访问
```

### 2. 详细迁移计划

#### A. EventBus迁移到基础设施层

```csharp
// ✅ 目标位置：MF.Infrastructure.EventBus
namespace MF.Infrastructure.EventBus
{
    /// <summary>
    /// 事件总线接口
    /// </summary>
    public interface IEventBus
    {
        /// <summary>
        /// 发布事件
        /// </summary>
        Task PublishAsync<TEvent>(TEvent @event) where TEvent : IEvent;
        
        /// <summary>
        /// 同步发布事件
        /// </summary>
        void Publish<TEvent>(TEvent @event) where TEvent : IEvent;
        
        /// <summary>
        /// 订阅事件
        /// </summary>
        IDisposable Subscribe<TEvent>(Action<TEvent> handler) where TEvent : IEvent;
        
        /// <summary>
        /// 异步订阅事件
        /// </summary>
        IDisposable Subscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent;
        
        /// <summary>
        /// 条件订阅事件
        /// </summary>
        IDisposable Subscribe<TEvent>(Func<TEvent, bool> filter, Action<TEvent> handler) where TEvent : IEvent;
        
        /// <summary>
        /// 一次性订阅事件
        /// </summary>
        IDisposable SubscribeOnce<TEvent>(Action<TEvent> handler) where TEvent : IEvent;
    }
    
    /// <summary>
    /// 基于R3的事件总线实现
    /// </summary>
    public class R3EventBus : IEventBus, IDisposable
    {
        private readonly Dictionary<Type, Subject<object>> _subjects = new();
        private readonly CompositeDisposable _disposables = new();
        private readonly ILogger<R3EventBus> _logger;
        private readonly EventBusConfig _config;
        private bool _disposed;
        
        public R3EventBus(ILogger<R3EventBus> logger, EventBusConfig config)
        {
            _logger = logger;
            _config = config;
        }
        
        public async Task PublishAsync<TEvent>(TEvent @event) where TEvent : IEvent
        {
            if (_disposed) return;
            
            try
            {
                _logger.LogTrace("Publishing event: {EventType}", typeof(TEvent).Name);
                
                var subject = GetOrCreateSubject<TEvent>();
                
                if (_config.EnableAsyncPublishing)
                {
                    await Task.Run(() => subject.OnNext(@event));
                }
                else
                {
                    subject.OnNext(@event);
                }
                
                _logger.LogTrace("Event published: {EventType}", typeof(TEvent).Name);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to publish event: {EventType}", typeof(TEvent).Name);
                throw;
            }
        }
        
        public void Publish<TEvent>(TEvent @event) where TEvent : IEvent
        {
            if (_disposed) return;
            
            try
            {
                _logger.LogTrace("Publishing event synchronously: {EventType}", typeof(TEvent).Name);
                
                var subject = GetOrCreateSubject<TEvent>();
                subject.OnNext(@event);
                
                _logger.LogTrace("Event published synchronously: {EventType}", typeof(TEvent).Name);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to publish event synchronously: {EventType}", typeof(TEvent).Name);
                throw;
            }
        }
        
        public IDisposable Subscribe<TEvent>(Action<TEvent> handler) where TEvent : IEvent
        {
            if (_disposed) throw new ObjectDisposedException(nameof(R3EventBus));
            
            try
            {
                _logger.LogTrace("Subscribing to event: {EventType}", typeof(TEvent).Name);
                
                var subject = GetOrCreateSubject<TEvent>();
                var subscription = subject.Subscribe(evt =>
                {
                    try
                    {
                        handler((TEvent)evt);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error in event handler for: {EventType}", typeof(TEvent).Name);
                        if (_config.ThrowOnHandlerError)
                            throw;
                    }
                });
                
                _logger.LogTrace("Subscribed to event: {EventType}", typeof(TEvent).Name);
                return subscription;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to subscribe to event: {EventType}", typeof(TEvent).Name);
                throw;
            }
        }
        
        public IDisposable Subscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent
        {
            return Subscribe<TEvent>(evt =>
            {
                // 异步处理，但不阻塞事件发布
                _ = Task.Run(async () =>
                {
                    try
                    {
                        await handler(evt);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, "Error in async event handler for: {EventType}", typeof(TEvent).Name);
                    }
                });
            });
        }
        
        public IDisposable Subscribe<TEvent>(Func<TEvent, bool> filter, Action<TEvent> handler) where TEvent : IEvent
        {
            return Subscribe<TEvent>(evt =>
            {
                if (filter(evt))
                {
                    handler(evt);
                }
            });
        }
        
        public IDisposable SubscribeOnce<TEvent>(Action<TEvent> handler) where TEvent : IEvent
        {
            IDisposable? subscription = null;
            subscription = Subscribe<TEvent>(evt =>
            {
                try
                {
                    handler(evt);
                }
                finally
                {
                    subscription?.Dispose();
                }
            });
            return subscription;
        }
        
        private Subject<object> GetOrCreateSubject<TEvent>() where TEvent : IEvent
        {
            var eventType = typeof(TEvent);
            if (!_subjects.TryGetValue(eventType, out var subject))
            {
                subject = new Subject<object>();
                _subjects[eventType] = subject;
                _disposables.Add(subject);
            }
            return subject;
        }
        
        public void Dispose()
        {
            if (_disposed) return;
            
            _logger.LogInformation("Disposing EventBus");
            _disposables.Dispose();
            _subjects.Clear();
            _disposed = true;
        }
    }
    
    /// <summary>
    /// 事件总线配置
    /// </summary>
    public class EventBusConfig
    {
        public bool EnableAsyncPublishing { get; set; } = false;
        public bool ThrowOnHandlerError { get; set; } = false;
        public int MaxConcurrentHandlers { get; set; } = 10;
        public TimeSpan HandlerTimeout { get; set; } = TimeSpan.FromSeconds(30);
    }
}
```

#### B. LogSystem迁移到基础设施层

```csharp
// ✅ 目标位置：MF.Infrastructure.Logging
namespace MF.Infrastructure.Logging
{
    /// <summary>
    /// 游戏日志接口
    /// </summary>
    public interface IGameLogger
    {
        void Debug(string message, params object[] args);
        void Info(string message, params object[] args);
        void Warning(string message, params object[] args);
        void Error(string message, params object[] args);
        void Error(Exception exception, string message, params object[] args);
        void Fatal(string message, params object[] args);
        void Fatal(Exception exception, string message, params object[] args);
        
        void SetLevel(LogLevel level);
        void SetColor(LogLevel level, Color color);
        void EnableFileLogging(bool enable);
        void SetLogFilePath(string path);
    }
    
    /// <summary>
    /// Godot游戏日志实现
    /// </summary>
    public class GodotGameLogger : IGameLogger, IDisposable
    {
        private static readonly Dictionary<LogLevel, Color> DefaultLogColors = new()
        {
            { LogLevel.Debug, Colors.Cyan },
            { LogLevel.Info, Colors.White },
            { LogLevel.Warning, Colors.Yellow },
            { LogLevel.Error, Colors.Red },
            { LogLevel.Fatal, Colors.DarkRed }
        };
        
        private LogLevel _currentLevel = LogLevel.Debug;
        private bool _enableFileLogging = false;
        private string _logFilePath = "user://logs/game.log";
        private FileAccess? _logFile;
        private Dictionary<LogLevel, Color> _logColors = new(DefaultLogColors);
        private readonly object _lock = new();
        private bool _disposed;
        
        public GodotGameLogger()
        {
            SetupFileLogging();
        }
        
        public void Debug(string message, params object[] args)
        {
            Log(LogLevel.Debug, message, args);
        }
        
        public void Info(string message, params object[] args)
        {
            Log(LogLevel.Info, message, args);
        }
        
        public void Warning(string message, params object[] args)
        {
            Log(LogLevel.Warning, message, args);
        }
        
        public void Error(string message, params object[] args)
        {
            Log(LogLevel.Error, message, args);
        }
        
        public void Error(Exception exception, string message, params object[] args)
        {
            var fullMessage = $"{string.Format(message, args)}\nException: {exception}";
            Log(LogLevel.Error, fullMessage);
        }
        
        public void Fatal(string message, params object[] args)
        {
            Log(LogLevel.Fatal, message, args);
        }
        
        public void Fatal(Exception exception, string message, params object[] args)
        {
            var fullMessage = $"{string.Format(message, args)}\nException: {exception}";
            Log(LogLevel.Fatal, fullMessage);
        }
        
        public void SetLevel(LogLevel level)
        {
            _currentLevel = level;
        }
        
        public void SetColor(LogLevel level, Color color)
        {
            _logColors[level] = color;
        }
        
        public void EnableFileLogging(bool enable)
        {
            lock (_lock)
            {
                _enableFileLogging = enable;
                if (enable)
                {
                    SetupFileLogging();
                }
                else
                {
                    _logFile?.Close();
                    _logFile = null;
                }
            }
        }
        
        public void SetLogFilePath(string path)
        {
            lock (_lock)
            {
                _logFilePath = path;
                if (_enableFileLogging)
                {
                    _logFile?.Close();
                    SetupFileLogging();
                }
            }
        }
        
        private void Log(LogLevel level, string message, params object[] args)
        {
            if (level < _currentLevel || _disposed) return;
            
            try
            {
                var formattedMessage = args.Length > 0 ? string.Format(message, args) : message;
                var timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.fff");
                var logMessage = $"[{timestamp}] [{level}] {formattedMessage}";
                
                // 控制台输出
                if (_logColors.TryGetValue(level, out var color))
                {
                    GD.PrintRich($"[color={color.ToHtml()}]{logMessage}[/color]");
                }
                else
                {
                    GD.Print(logMessage);
                }
                
                // 文件输出
                if (_enableFileLogging)
                {
                    WriteToFile(logMessage);
                }
            }
            catch (Exception ex)
            {
                GD.PrintErr($"Logging error: {ex.Message}");
            }
        }
        
        private void SetupFileLogging()
        {
            if (!_enableFileLogging) return;
            
            try
            {
                var logDir = _logFilePath.GetBaseDir();
                if (!DirAccess.DirExistsAbsolute(logDir))
                {
                    DirAccess.MakeDirRecursiveAbsolute(logDir);
                }
                
                _logFile = FileAccess.Open(_logFilePath, FileAccess.ModeFlags.Write);
                if (_logFile != null)
                {
                    _logFile.SeekEnd();
                }
            }
            catch (Exception ex)
            {
                GD.PrintErr($"Failed to setup file logging: {ex.Message}");
                _enableFileLogging = false;
            }
        }
        
        private void WriteToFile(string message)
        {
            lock (_lock)
            {
                try
                {
                    _logFile?.StoreLine(message);
                    _logFile?.Flush();
                }
                catch (Exception ex)
                {
                    GD.PrintErr($"Failed to write to log file: {ex.Message}");
                }
            }
        }
        
        public void Dispose()
        {
            if (_disposed) return;
            
            lock (_lock)
            {
                _logFile?.Close();
                _logFile = null;
                _disposed = true;
            }
        }
    }
}
```

#### C. ResourceSystem拆分重构

```csharp
// ✅ 基础设施层：MF.Infrastructure.Caching
namespace MF.Infrastructure.Caching
{
    /// <summary>
    /// 资源缓存服务
    /// </summary>
    public class ResourceCacheService : ICacheService
    {
        private readonly ConcurrentDictionary<string, CacheNode> _cache = new();
        private readonly IMemoryMonitor _memoryMonitor;
        private readonly ICacheStatistics _statistics;
        private readonly ILogger<ResourceCacheService> _logger;
        private long _totalCacheSize;
        
        public ResourceCacheService(
            IMemoryMonitor memoryMonitor,
            ICacheStatistics statistics,
            ILogger<ResourceCacheService> logger)
        {
            _memoryMonitor = memoryMonitor;
            _statistics = statistics;
            _logger = logger;
            
            _memoryMonitor.OnAutoReleaseTriggered += AutoReleaseResources;
        }
        
        public async Task<T?> GetAsync<T>(string key) where T : class
        {
            if (_cache.TryGetValue(key, out var node))
            {
                node.LastAccessed = DateTime.Now;
                _statistics.RecordHit();
                _logger.LogTrace("Cache hit: {Key}", key);
                return node.Resource as T;
            }
            
            _statistics.RecordMiss();
            _logger.LogTrace("Cache miss: {Key}", key);
            return null;
        }
        
        public async Task SetAsync<T>(string key, T value, TimeSpan? expiration = null) where T : class
        {
            if (value is not Resource resource)
            {
                _logger.LogWarning("Attempted to cache non-Resource object: {Type}", typeof(T).Name);
                return;
            }
            
            var size = CalculateResourceSize(resource);
            var node = new CacheNode
            {
                Resource = resource,
                Size = size,
                LastAccessed = DateTime.Now,
                Policy = CachePolicy.Normal
            };
            
            if (_cache.TryAdd(key, node))
            {
                Interlocked.Add(ref _totalCacheSize, size);
                _statistics.RecordSet();
                _logger.LogTrace("Cached resource: {Key}, Size: {Size}", key, size);
                
                // 检查内存压力
                _memoryMonitor.CheckMemoryPressure(_totalCacheSize);
            }
        }
        
        private void AutoReleaseResources()
        {
            _logger.LogInformation("Auto-releasing cached resources due to memory pressure");
            
            var itemsToRemove = _cache.Values
                .OrderBy(n => n.LastAccessed)
                .Take(_cache.Count / 4) // 释放25%的缓存
                .ToList();
            
            foreach (var item in itemsToRemove)
            {
                var keyToRemove = _cache.FirstOrDefault(kvp => kvp.Value == item).Key;
                if (keyToRemove != null && _cache.TryRemove(keyToRemove, out var removedNode))
                {
                    Interlocked.Add(ref _totalCacheSize, -removedNode.Size);
                    _statistics.RecordEviction(EvictionReason.MemoryPressure);
                }
            }
            
            _logger.LogInformation("Released {Count} cached resources", itemsToRemove.Count);
        }
        
        private long CalculateResourceSize(Resource resource)
        {
            return resource switch
            {
                Texture2D texture => texture.GetWidth() * texture.GetHeight() * 4, // RGBA
                AudioStream audio => 1024 * 1024, // 估算1MB
                PackedScene scene => 512 * 1024, // 估算512KB
                _ => 1024 // 默认1KB
            };
        }
    }
}

// ✅ 基础设施层：MF.Infrastructure.Monitoring
namespace MF.Infrastructure.Monitoring
{
    /// <summary>
    /// 内存监控服务
    /// </summary>
    public interface IMemoryMonitor
    {
        event Action OnAutoReleaseTriggered;
        void CheckMemoryPressure(long currentUsage);
        void StartMonitoring();
        void StopMonitoring();
    }
    
    public class MemoryMonitor : IMemoryMonitor, IDisposable
    {
        private bool _isRunning;
        private bool _disposed;
        private readonly Timer _monitorTimer;
        private readonly ILogger<MemoryMonitor> _logger;
        
        public event Action? OnAutoReleaseTriggered;
        
        public long AutoReleaseThreshold { get; set; } = 800 * 1024 * 1024; // 800MB
        public TimeSpan CheckInterval { get; set; } = TimeSpan.FromSeconds(15);
        
        public MemoryMonitor(ILogger<MemoryMonitor> logger)
        {
            _logger = logger;
            _monitorTimer = new Timer(CheckMemoryUsage, null, Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
        }
        
        public void StartMonitoring()
        {
            if (_isRunning || _disposed) return;
            
            _isRunning = true;
            _monitorTimer.Change(CheckInterval, CheckInterval);
            _logger.LogInformation("Memory monitoring started");
        }
        
        public void StopMonitoring()
        {
            if (!_isRunning) return;
            
            _isRunning = false;
            _monitorTimer.Change(Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
            _logger.LogInformation("Memory monitoring stopped");
        }
        
        public void CheckMemoryPressure(long currentUsage)
        {
            if (currentUsage > AutoReleaseThreshold)
            {
                _logger.LogWarning("Memory pressure detected: {CurrentUsage} > {Threshold}", 
                    currentUsage, AutoReleaseThreshold);
                OnAutoReleaseTriggered?.Invoke();
            }
        }
        
        private void CheckMemoryUsage(object? state)
        {
            try
            {
                var memoryUsage = GC.GetTotalMemory(false);
                CheckMemoryPressure(memoryUsage);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during memory monitoring");
            }
        }
        
        public void Dispose()
        {
            if (_disposed) return;
            
            StopMonitoring();
            _monitorTimer.Dispose();
            _disposed = true;
        }
    }
}

// ✅ 服务层：MF.Services.ResourceService
namespace MF.Services
{
    /// <summary>
    /// 资源管理服务
    /// </summary>
    public interface IResourceService
    {
        Task<T?> GetResourceAsync<T>(string path) where T : Resource;
        Task<IEnumerable<T>> GetResourcesAsync<T>(IEnumerable<string> paths) where T : Resource;
        Task PreloadResourceAsync(string path);
        Task PreloadResourcesAsync(IEnumerable<string> paths);
        Task<bool> ExistsAsync(string path);
        Task InvalidateAsync(string path);
        Task InvalidateAllAsync();
        Task<ResourceStatistics> GetStatisticsAsync();
    }
    
    public class ResourceService : IResourceService
    {
        private readonly IResourceRepository _resourceRepository;
        private readonly ICacheService _cacheService;
        private readonly IEventBus _eventBus;
        private readonly ILogger<ResourceService> _logger;
        
        public ResourceService(
            IResourceRepository resourceRepository,
            ICacheService cacheService,
            IEventBus eventBus,
            ILogger<ResourceService> logger)
        {
            _resourceRepository = resourceRepository;
            _cacheService = cacheService;
            _eventBus = eventBus;
            _logger = logger;
        }
        
        public async Task<T?> GetResourceAsync<T>(string path) where T : Resource
        {
            _logger.LogDebug("Getting resource: {Path}", path);
            
            try
            {
                var resource = await _resourceRepository.GetResourceAsync<T>(path);
                
                if (resource != null)
                {
                    await _eventBus.PublishAsync(new ResourceLoadedEvent
                    {
                        Path = path,
                        ResourceType = typeof(T).Name,
                        LoadTime = DateTime.UtcNow
                    });
                }
                
                return resource;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to get resource: {Path}", path);
                
                await _eventBus.PublishAsync(new ResourceLoadFailedEvent
                {
                    Path = path,
                    ResourceType = typeof(T).Name,
                    Error = ex.Message,
                    FailTime = DateTime.UtcNow
                });
                
                throw;
            }
        }
        
        public async Task<IEnumerable<T>> GetResourcesAsync<T>(IEnumerable<string> paths) where T : Resource
        {
            var tasks = paths.Select(path => GetResourceAsync<T>(path));
            var results = await Task.WhenAll(tasks);
            return results.Where(r => r != null).Cast<T>();
        }
        
        public async Task PreloadResourceAsync(string path)
        {
            _logger.LogDebug("Preloading resource: {Path}", path);
            
            try
            {
                await _resourceRepository.PreloadResourceAsync(path);
                
                await _eventBus.PublishAsync(new ResourcePreloadedEvent
                {
                    Path = path,
                    PreloadTime = DateTime.UtcNow
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to preload resource: {Path}", path);
                throw;
            }
        }
        
        public async Task PreloadResourcesAsync(IEnumerable<string> paths)
        {
            var tasks = paths.Select(PreloadResourceAsync);
            await Task.WhenAll(tasks);
        }
        
        public async Task<bool> ExistsAsync(string path)
        {
            return await _resourceRepository.ExistsAsync(path);
        }
        
        public async Task InvalidateAsync(string path)
        {
            await _cacheService.RemoveAsync(path);
            
            await _eventBus.PublishAsync(new ResourceInvalidatedEvent
            {
                Path = path,
                InvalidateTime = DateTime.UtcNow
            });
        }
        
        public async Task InvalidateAllAsync()
        {
            await _cacheService.ClearAsync();
            
            await _eventBus.PublishAsync(new AllResourcesInvalidatedEvent
            {
                InvalidateTime = DateTime.UtcNow
            });
        }
        
        public async Task<ResourceStatistics> GetStatisticsAsync()
        {
            var cacheStats = await _cacheService.GetStatisticsAsync();
            
            return new ResourceStatistics
            {
                CacheHits = cacheStats.Hits,
                CacheMisses = cacheStats.Misses,
                CacheHitRate = cacheStats.HitRate,
                TotalCachedItems = cacheStats.TotalItems,
                TotalCacheSize = cacheStats.TotalSize
            };
        }
    }
}

// ✅ 仓储层：MF.Repositories.ResourceRepository
namespace MF.Repositories
{
    /// <summary>
    /// 资源仓储：只负责数据访问
    /// </summary>
    public class ResourceRepository : IResourceRepository
    {
        private readonly IResourceLoader _resourceLoader;
        private readonly ICacheService _cacheService;
        private readonly IResourceValidator _validator;
        private readonly ILogger<ResourceRepository> _logger;
        
        public ResourceRepository(
            IResourceLoader resourceLoader,
            ICacheService cacheService,
            IResourceValidator validator,
            ILogger<ResourceRepository> logger)
        {
            _resourceLoader = resourceLoader;
            _cacheService = cacheService;
            _validator = validator;
            _logger = logger;
        }
        
        public async Task<T?> GetResourceAsync<T>(string path) where T : Resource
        {
            // 业务验证
            if (!_validator.IsValidPath(path))
            {
                throw new ArgumentException($"Invalid resource path: {path}");
            }
            
            // 尝试从缓存获取
            var cachedResource = await _cacheService.GetAsync<T>(path);
            if (cachedResource != null)
            {
                return cachedResource;
            }
            
            // 从存储加载
            var resource = await _resourceLoader.LoadAsync<T>(path);
            if (resource != null)
            {
                // 缓存资源
                await _cacheService.SetAsync(path, resource);
            }
            
            return resource;
        }
        
        public async Task<bool> ExistsAsync(string path)
        {
            return await _resourceLoader.ExistsAsync(path);
        }
        
        public async Task<ResourceMetadata> GetMetadataAsync(string path)
        {
            return await _resourceLoader.GetMetadataAsync(path);
        }
        
        public async Task PreloadResourceAsync(string path)
        {
            await _resourceLoader.PreloadAsync(path);
        }
    }
}
```

## 迁移实施计划

### 第一阶段：创建新的基础设施层

1. **创建基础设施项目**
   ```
   MF.Infrastructure/
   ├── EventBus/
   ├── Logging/
   ├── Caching/
   ├── Monitoring/
   └── ResourceLoading/
   ```

2. **迁移EventBus**
   - 创建 `MF.Infrastructure.EventBus` 项目
   - 迁移 `EventBusRepo` 到 `R3EventBus`
   - 更新接口和实现

3. **迁移LogSystem**
   - 创建 `MF.Infrastructure.Logging` 项目
   - 迁移 `LoggerRepo` 到 `GodotGameLogger`
   - 改进日志功能

4. **拆分ResourceSystem**
   - 缓存相关 → `MF.Infrastructure.Caching`
   - 监控相关 → `MF.Infrastructure.Monitoring`
   - 加载相关 → `MF.Infrastructure.ResourceLoading`

### 第二阶段：创建服务层

1. **创建服务项目**
   ```
   MF.Services/
   ├── ResourceService/
   ├── PlayerService/
   └── GameDataService/
   ```

2. **实现ResourceService**
   - 整合资源管理的业务逻辑
   - 使用基础设施层的服务
   - 发布业务事件

### 第三阶段：重构仓储层

1. **简化仓储层**
   - 移除非数据访问职责
   - 只保留纯粹的数据访问逻辑
   - 使用基础设施层服务

2. **更新依赖注入**
   ```csharp
   // 注册基础设施服务
   services.AddInfrastructureServices();
   
   // 注册服务层
   services.AddApplicationServices();
   
   // 注册仓储层
   services.AddRepositoryServices();
   ```

### 第四阶段：更新引用和测试

1. **更新项目引用**
   - 应用层引用服务层
   - 服务层引用仓储层和基础设施层
   - 仓储层引用基础设施层

2. **迁移现有代码**
   - 更新所有使用旧接口的代码
   - 使用适配器模式保证兼容性

3. **添加测试**
   - 为每个层次添加单元测试
   - 添加集成测试

## 迁移后的优势

### 1. 清晰的职责分离

| 层次 | 职责 | 示例 |
|------|------|------|
| **服务层** | 业务逻辑、流程协调 | `ResourceService`、业务规则 |
| **仓储层** | 数据访问抽象 | `ResourceRepository`、数据查询 |
| **基础设施层** | 技术服务提供 | `EventBus`、`Logger`、`Cache` |

### 2. 更好的可测试性

```csharp
// ✅ 服务层测试：Mock基础设施和仓储
[Test]
public async Task GetResourceAsync_ShouldPublishEvent_WhenResourceLoaded()
{
    // Arrange
    var mockRepository = new Mock<IResourceRepository>();
    var mockEventBus = new Mock<IEventBus>();
    var mockLogger = new Mock<ILogger<ResourceService>>();
    
    var expectedResource = new Texture2D();
    mockRepository.Setup(r => r.GetResourceAsync<Texture2D>("test.png"))
                  .ReturnsAsync(expectedResource);
    
    var service = new ResourceService(mockRepository.Object, mockEventBus.Object, mockLogger.Object);
    
    // Act
    var result = await service.GetResourceAsync<Texture2D>("test.png");
    
    // Assert
    Assert.AreEqual(expectedResource, result);
    mockEventBus.Verify(e => e.PublishAsync(It.IsAny<ResourceLoadedEvent>()), Times.Once);
}
```

### 3. 更好的可维护性

```csharp
// ✅ 基础设施服务可以独立升级
public class RedisEventBus : IEventBus
{
    // 可以替换为Redis实现，不影响业务代码
}

public class ElasticsearchLogger : IGameLogger
{
    // 可以替换为Elasticsearch实现，不影响业务代码
}
```

### 4. 更好的扩展性

```csharp
// ✅ 新增功能不影响现有层次
public class ResourcePreloadService : IResourcePreloadService
{
    private readonly IResourceService _resourceService;
    private readonly IEventBus _eventBus;
    
    // 新的服务可以组合现有服务
    public async Task PreloadSceneResourcesAsync(string scenePath)
    {
        // 预加载场景相关资源的业务逻辑
    }
}
```

## 总结

你的判断完全正确！这三个模块确实应该迁移：

1. **EventBus** → 基础设施层（`MF.Infrastructure.EventBus`）
2. **LogSystem** → 基础设施层（`MF.Infrastructure.Logging`）
3. **ResourceSystem** → 拆分到基础设施层和服务层

这种迁移将带来：
- ✅ **职责清晰**：每层都有明确的职责边界
- ✅ **易于测试**：各层可以独立测试
- ✅ **技术无关**：业务逻辑不依赖具体技术实现
- ✅ **易于扩展**：新增功能不影响现有架构
- ✅ **配置灵活**：可以运行时切换不同实现

这是一个重要的架构重构，将显著提升代码的质量和可维护性！