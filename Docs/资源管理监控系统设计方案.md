# 资源管理监控系统设计方案

## 1. 核心需求分析

### 1.1 服务需求识别

**资源加载服务需求**：
- 获取缓存资源
- 存储资源到缓存
- 清理过期缓存

**其他服务需求**：
- 场景管理器：预加载场景资源
- 音频管理器：缓存音频文件
- UI管理器：缓存纹理资源

**管理需求**：
- 查看系统性能报告
- 监控内存使用情况
- 配置缓存策略

### 1.2 系统职责定义

**资源管理监控系统职责**：
- 提供统一的缓存服务
- 自动监控资源使用情况
- 管理内存压力和清理
- 生成性能报告

## 2. 接口设计

### 2.1 缓存服务接口

```csharp
/// <summary>
/// 资源缓存服务 - 供其他服务使用
/// </summary>
public interface IResourceCacheService
{
    /// <summary>
    /// 获取缓存资源
    /// </summary>
    Task<T?> GetAsync<T>(string key) where T : class;
    
    /// <summary>
    /// 存储资源到缓存
    /// </summary>
    Task SetAsync<T>(string key, T resource, TimeSpan? expiration = null) where T : class;
    
    /// <summary>
    /// 移除缓存资源
    /// </summary>
    Task RemoveAsync(string key);
    
    /// <summary>
    /// 清理过期缓存
    /// </summary>
    Task CleanupAsync();
}
```

### 2.2 监控查询接口

```csharp
/// <summary>
/// 资源监控查询服务 - 供管理使用
/// </summary>
public interface IResourceMonitorService
{
    /// <summary>
    /// 获取缓存统计
    /// </summary>
    Task<CacheStatistics> GetCacheStatisticsAsync();
    
    /// <summary>
    /// 获取内存使用情况
    /// </summary>
    Task<MemoryUsage> GetMemoryUsageAsync();
    
    /// <summary>
    /// 获取性能报告
    /// </summary>
    Task<PerformanceReport> GetPerformanceReportAsync(TimeSpan period);
}
```

### 2.3 数据模型

```csharp
public class CacheStatistics
{
    public int TotalItems { get; set; }
    public long TotalSize { get; set; }
    public int HitCount { get; set; }
    public int MissCount { get; set; }
    public double HitRate => TotalItems > 0 ? (double)HitCount / (HitCount + MissCount) : 0;
}

public class MemoryUsage
{
    public long CurrentUsage { get; set; }
    public long MaxUsage { get; set; }
    public double UsagePercentage { get; set; }
}

public class PerformanceReport
{
    public TimeSpan Period { get; set; }
    public CacheStatistics CacheStats { get; set; }
    public MemoryUsage MemoryStats { get; set; }
    public int TotalRequests { get; set; }
    public TimeSpan AverageResponseTime { get; set; }
}
```

## 3. 系统架构

### 3.1 核心思想

系统围绕一个主组件 `ResourceManager` 进行设计。该组件是整个系统的核心协调者（Mediator），负责：
- **对外通信**：为业务层提供统一的 `IResourceCacheService` 和 `IResourceMonitorService` 接口。
- **对内调度**：管理和调度内部的各个功能组件（如 `CacheService`, `MemoryMonitor` 等）。
- **事件处理**：监听并处理由内部组件触发的事件（如内存压力、性能异常等），并执行相应的策略。

### 3.2 架构图

```
                                ▲
                                │ (IResourceCacheService / IResourceMonitorService)
                                │
┌───────────────────────────────┴───────────────────────────────┐
│                         业务服务层                             │
│  (ResourceLoader, SceneManager, AudioManager, ...)            │
└───────────────────────────────┬───────────────────────────────┘
                                │
┌───────────────────────────────▼───────────────────────────────┐
│                   ResourceManager (主组件)                      │
├───────────────────────────────────────────────────────────────┤
│ 协调 & 调度 │ 事件中心 │ 对外接口实现                           │
└──────┬──────────────┬──────────────┬──────────────┬──────────┘
       │              │              │              │
 (调度)│         (监听)│         (调度)│         (调度)│
       │              │              │              │
┌──────▼──────┐  ┌─────┴───────┐  ┌─────▼───────┐  ┌─────▼───────┐
│ CacheService│  │MemoryMonitor│  │Perf. Monitor│  │ReportService│
│ (缓存管理)  │  │(内存监控)   │  │(性能监控)   │  │(报告生成)   │
└─────────────┘  └──────┬──────┘  └─────────────┘  └─────────────┘
                        │
                        │ (内存压力事件)
                        └────────►
```

### 3.3 通信流程

1. **外部请求**：业务服务（如 `ResourceLoader`）通过 `IResourceCacheService` 接口向 `ResourceManager` 发起请求（如 `GetAsync`）。
2. **内部调度**：`ResourceManager` 将请求委托给相应的内部组件处理（如 `CacheService`）。
3. **事件上报**：内部组件在工作时，如果发现异常情况（如 `MemoryMonitor` 检测到内存超限），会发布一个事件。
4. **事件响应**：`ResourceManager` 监听到事件后，会根据预设策略调度其他组件来响应。例如，监听到 `MemoryPressureEvent` 后，会命令 `CacheService` 执行缓存清理。

## 4. 组件职责

### 4.1 ResourceManager (主组件)
- **职责**：作为系统的统一入口和协调中心。
- **实现**：
    - 实现 `IResourceCacheService` 和 `IResourceMonitorService` 接口。
    - 持有 `CacheService`, `MemoryMonitor` 等内部组件的实例。
    - 订阅内部组件的事件，并实现事件处理逻辑。

### 4.2 CacheService (缓存服务)
- **职责**：负责所有缓存的底层管理，包括增、删、查、改和清理策略（LRU, TTL）。
- **通信**：被 `ResourceManager` 直接调用。

### 4.3 MemoryMonitor (内存监控器)
- **职责**：定期检测当前应用的内存使用情况。
- **通信**：当内存使用率超过阈值时，发布 `MemoryPressureEvent` 事件。

### 4.4 PerformanceMonitor (性能监控器)
- **职责**：记录缓存命中率、资源加载耗时等性能指标。
- **通信**：被 `ResourceManager` 调用以更新数据，并为 `ReportService` 提供原始数据。

### 4.5 ReportService (报告服务)
- **职责**：根据 `PerformanceMonitor` 和 `CacheService` 的数据，生成结构化的性能报告。
- **通信**：被 `ResourceManager` 调用以生成报告。

## 5. 实现要点

### 5.1 事件驱动的内部协作
系统内部通过事件总线（Event Bus）或简单的事件委托实现解耦。

```csharp
// 内存监控器发布事件
public class MemoryMonitor
{
    public event Action<MemoryPressureEventArgs> MemoryPressureDetected;

    public void CheckMemory()
    {
        if (IsMemoryUsageHigh())
        {
            MemoryPressureDetected?.Invoke(new MemoryPressureEventArgs(...));
        }
    }
}

// 主组件订阅并处理事件
public class ResourceManager : IResourceCacheService
{
    private readonly MemoryMonitor _memoryMonitor;
    private readonly CacheService _cacheService;

    public ResourceManager(MemoryMonitor memoryMonitor, CacheService cacheService)
    {
        _memoryMonitor = memoryMonitor;
        _cacheService = cacheService;
        // 订阅事件
        _memoryMonitor.MemoryPressureDetected += OnMemoryPressureDetected;
    }

    private void OnMemoryPressureDetected(MemoryPressureEventArgs args)
    {
        // 调度缓存服务进行清理
        _cacheService.Cleanup(CacheCleanupReason.MemoryPressure);
    }
}
```

### 5.2 配置管理
配置项保持不变，但由 `ResourceManager` 分发给对应的子组件。
```csharp
public class ResourceSystemConfig
{
    public long MaxMemorySize { get; set; } = 100 * 1024 * 1024; // 100MB
    public TimeSpan DefaultExpiration { get; set; } = TimeSpan.FromHours(1);
    public double MemoryPressureThreshold { get; set; } = 0.8; // 80%
    public TimeSpan CleanupInterval { get; set; } = TimeSpan.FromMinutes(5);
}
```

## 5. 使用示例

### 5.1 资源加载服务使用
```csharp
public class GodotResourceLoader : IResourceLoader
{
    private readonly IResourceCacheService _cache;
    
    public async Task<T?> LoadAsync<T>(string path) where T : class
    {
        // 1. 尝试从缓存获取
        var cached = await _cache.GetAsync<T>(path);
        if (cached != null) return cached;
        
        // 2. 加载资源
        var resource = await LoadFromDiskAsync<T>(path);
        
        // 3. 存储到缓存
        if (resource != null)
        {
            await _cache.SetAsync(path, resource);
        }
        
        return resource;
    }
}
```

### 5.2 管理界面使用
```csharp
public class ResourceMonitorController
{
    private readonly IResourceMonitorService _monitor;
    
    public async Task<IActionResult> GetDashboard()
    {
        var stats = await _monitor.GetCacheStatisticsAsync();
        var memory = await _monitor.GetMemoryUsageAsync();
        var report = await _monitor.GetPerformanceReportAsync(TimeSpan.FromHours(1));
        
        return View(new DashboardViewModel
        {
            CacheStats = stats,
            MemoryUsage = memory,
            PerformanceReport = report
        });
    }
}
```

## 7. 总结

这个设计方案聚焦于实际需求：

1. **简洁接口**：只提供业务真正需要的功能
2. **职责清晰**：缓存管理和监控查询分离
3. **易于使用**：其他服务只需要关心缓存操作
4. **自动监控**：系统内部自动收集性能数据
5. **配置简单**：最小化配置项，合理默认值

通过这种设计，资源加载服务只需要使用 `IResourceCacheService` 进行缓存操作，所有的监控、清理、统计都由系统内部自动处理，实现了真正的关注点分离。