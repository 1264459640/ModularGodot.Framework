# 资源管理监控系统实现方案

## 1. 概述

基于现有的 ModularGodot 框架架构和《资源管理监控系统设计方案》，本文档提供了具体的实现方案，包括文件结构、接口扩展和代码实现。

## 2. 现有架构分析

### 2.1 当前框架结构

```
ModularGodot.Framework/Core/
├── 0_Base/                    # 基础层
│   ├── MF.Commons/            # 通用组件
│   ├── MF.Contexts/           # 上下文管理
│   └── MF.Services.Abstractions/  # 服务抽象
├── 1_1_Frontend/              # 前端层
│   └── MF.Nodes.Abstractions/ # 节点抽象
├── 1_2_Backend/               # 后端层
│   ├── MF.Data/               # 数据层
│   ├── MF.Infrastructure.Abstractions/  # 基础设施抽象
│   ├── MF.Infrastructure/     # 基础设施实现
│   ├── MF.Repositories.Abstractions/   # 仓储抽象
│   └── MF.Repositories/       # 仓储实现
└── 2_App/                     # 应用层
    ├── MF.Services.Abstractions/  # 服务抽象
    ├── MF.Services/           # 服务实现
    ├── MF.Commands/           # 命令
    ├── MF.CommandHandlers/    # 命令处理器
    └── MF.Events/             # 事件
```

### 2.2 现有接口分析

**已存在的相关接口**：
- `ICacheService` - 基础缓存服务接口
- `IMemoryMonitor` - 内存监控接口
- `IPerformanceMonitor` - 性能监控接口
- `IEventBus` - 事件总线接口
- `IResourceLoader` - 资源加载器接口
- `ResourceLoaderStatistics` - 资源加载统计

## 3. 实现方案

### 3.1 接口扩展策略

基于现有接口，我们需要：
1. **扩展现有接口**：在 `MF.Services.Abstractions` 中添加资源管理监控相关接口
2. **复用基础设施**：利用现有的 `ICacheService`、`IMemoryMonitor`、`IPerformanceMonitor`
3. **集成事件系统**：使用现有的 `IEventBus` 和 `EventBase`

### 3.2 文件结构规划

```
2_App/MF.Services.Abstractions/Core/ResourceManagement/
├── IResourceCacheService.cs           # 资源缓存服务接口
├── IResourceMonitorService.cs         # 资源监控服务接口
├── Models/
│   ├── CacheStatistics.cs            # 缓存统计模型
│   ├── MemoryUsage.cs                 # 内存使用模型
│   ├── PerformanceReport.cs           # 性能报告模型
│   └── ResourceSystemConfig.cs        # 系统配置模型
└── Events/
    ├── MemoryPressureEvent.cs         # 内存压力事件
    ├── CacheCleanupEvent.cs           # 缓存清理事件
    └── ResourceLoadEvent.cs           # 资源加载事件

2_App/MF.Services/Core/ResourceManagement/
├── ResourceManager.cs                 # 主组件实现
├── Internal/
│   ├── CacheService.cs               # 内部缓存服务
│   ├── MemoryMonitorService.cs       # 内存监控服务
│   ├── PerformanceMonitorService.cs  # 性能监控服务
│   └── ReportService.cs              # 报告生成服务
└── Extensions/
    └── ServiceCollectionExtensions.cs # DI 扩展

2_App/MF.Events/ResourceManagement/
├── MemoryPressureEvent.cs            # 内存压力事件实现
├── CacheCleanupEvent.cs              # 缓存清理事件实现
└── ResourceLoadEvent.cs              # 资源加载事件实现
```

## 4. 具体实现

### 4.1 服务抽象接口

#### 4.1.1 IResourceCacheService.cs

```csharp
using MF.Commons.Core.Enums.Infrastructure;

namespace MF.Services.Abstractions.Core.ResourceManagement;

/// <summary>
/// 资源缓存服务接口 - Standard级别
/// 供其他服务使用的统一缓存接口
/// </summary>
public interface IResourceCacheService
{
    /// <summary>
    /// 异步获取缓存资源
    /// </summary>
    /// <typeparam name="T">资源类型</typeparam>
    /// <param name="key">缓存键</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>资源实例</returns>
    Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default) where T : class;
    
    /// <summary>
    /// 异步存储资源到缓存
    /// </summary>
    /// <typeparam name="T">资源类型</typeparam>
    /// <param name="key">缓存键</param>
    /// <param name="resource">资源实例</param>
    /// <param name="expiration">过期时间</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>存储任务</returns>
    Task SetAsync<T>(string key, T resource, TimeSpan? expiration = null, CancellationToken cancellationToken = default) where T : class;
    
    /// <summary>
    /// 异步移除缓存资源
    /// </summary>
    /// <param name="key">缓存键</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>移除任务</returns>
    Task RemoveAsync(string key, CancellationToken cancellationToken = default);
    
    /// <summary>
    /// 异步清理过期缓存
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>清理任务</returns>
    Task CleanupAsync(CancellationToken cancellationToken = default);
    
    /// <summary>
    /// 检查缓存键是否存在
    /// </summary>
    /// <param name="key">缓存键</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>是否存在</returns>
    Task<bool> ExistsAsync(string key, CancellationToken cancellationToken = default);
}
```

#### 4.1.2 IResourceMonitorService.cs

```csharp
using MF.Services.Abstractions.Core.ResourceManagement.Models;

namespace MF.Services.Abstractions.Core.ResourceManagement;

/// <summary>
/// 资源监控查询服务接口 - Standard级别
/// 供管理和监控使用的查询接口
/// </summary>
public interface IResourceMonitorService
{
    /// <summary>
    /// 异步获取缓存统计信息
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>缓存统计</returns>
    Task<CacheStatistics> GetCacheStatisticsAsync(CancellationToken cancellationToken = default);
    
    /// <summary>
    /// 异步获取内存使用情况
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>内存使用情况</returns>
    Task<MemoryUsage> GetMemoryUsageAsync(CancellationToken cancellationToken = default);
    
    /// <summary>
    /// 异步获取性能报告
    /// </summary>
    /// <param name="period">统计周期</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>性能报告</returns>
    Task<PerformanceReport> GetPerformanceReportAsync(TimeSpan period, CancellationToken cancellationToken = default);
    
    /// <summary>
    /// 异步获取系统配置
    /// </summary>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>系统配置</returns>
    Task<ResourceSystemConfig> GetConfigurationAsync(CancellationToken cancellationToken = default);
    
    /// <summary>
    /// 异步更新系统配置
    /// </summary>
    /// <param name="config">新配置</param>
    /// <param name="cancellationToken">取消令牌</param>
    /// <returns>更新任务</returns>
    Task UpdateConfigurationAsync(ResourceSystemConfig config, CancellationToken cancellationToken = default);
}
```

### 4.2 数据模型

#### 4.2.1 CacheStatistics.cs

```csharp
namespace MF.Services.Abstractions.Core.ResourceManagement.Models;

/// <summary>
/// 缓存统计信息
/// </summary>
public class CacheStatistics
{
    /// <summary>
    /// 缓存项总数
    /// </summary>
    public int TotalItems { get; set; }
    
    /// <summary>
    /// 缓存总大小（字节）
    /// </summary>
    public long TotalSize { get; set; }
    
    /// <summary>
    /// 缓存命中次数
    /// </summary>
    public int HitCount { get; set; }
    
    /// <summary>
    /// 缓存未命中次数
    /// </summary>
    public int MissCount { get; set; }
    
    /// <summary>
    /// 缓存命中率
    /// </summary>
    public double HitRate => (HitCount + MissCount) > 0 ? (double)HitCount / (HitCount + MissCount) : 0;
    
    /// <summary>
    /// 过期项数量
    /// </summary>
    public int ExpiredItems { get; set; }
    
    /// <summary>
    /// 最后更新时间
    /// </summary>
    public DateTime LastUpdated { get; set; } = DateTime.UtcNow;
}
```

#### 4.2.2 MemoryUsage.cs

```csharp
namespace MF.Services.Abstractions.Core.ResourceManagement.Models;

/// <summary>
/// 内存使用情况
/// </summary>
public class MemoryUsage
{
    /// <summary>
    /// 当前内存使用量（字节）
    /// </summary>
    public long CurrentUsage { get; set; }
    
    /// <summary>
    /// 最大内存使用量（字节）
    /// </summary>
    public long MaxUsage { get; set; }
    
    /// <summary>
    /// 内存使用百分比
    /// </summary>
    public double UsagePercentage { get; set; }
    
    /// <summary>
    /// 可用内存（字节）
    /// </summary>
    public long AvailableMemory { get; set; }
    
    /// <summary>
    /// 垃圾回收次数
    /// </summary>
    public int GCCollectionCount { get; set; }
    
    /// <summary>
    /// 最后检查时间
    /// </summary>
    public DateTime LastChecked { get; set; } = DateTime.UtcNow;
}
```

#### 4.2.3 PerformanceReport.cs

```csharp
namespace MF.Services.Abstractions.Core.ResourceManagement.Models;

/// <summary>
/// 性能报告
/// </summary>
public class PerformanceReport
{
    /// <summary>
    /// 报告周期
    /// </summary>
    public TimeSpan Period { get; set; }
    
    /// <summary>
    /// 缓存统计
    /// </summary>
    public CacheStatistics CacheStats { get; set; } = new();
    
    /// <summary>
    /// 内存统计
    /// </summary>
    public MemoryUsage MemoryStats { get; set; } = new();
    
    /// <summary>
    /// 总请求数
    /// </summary>
    public int TotalRequests { get; set; }
    
    /// <summary>
    /// 平均响应时间
    /// </summary>
    public TimeSpan AverageResponseTime { get; set; }
    
    /// <summary>
    /// 最快响应时间
    /// </summary>
    public TimeSpan FastestResponseTime { get; set; }
    
    /// <summary>
    /// 最慢响应时间
    /// </summary>
    public TimeSpan SlowestResponseTime { get; set; }
    
    /// <summary>
    /// 错误数量
    /// </summary>
    public int ErrorCount { get; set; }
    
    /// <summary>
    /// 报告生成时间
    /// </summary>
    public DateTime GeneratedAt { get; set; } = DateTime.UtcNow;
}
```

#### 4.2.4 ResourceSystemConfig.cs

```csharp
namespace MF.Services.Abstractions.Core.ResourceManagement.Models;

/// <summary>
/// 资源系统配置
/// </summary>
public class ResourceSystemConfig
{
    /// <summary>
    /// 最大内存大小（字节）
    /// </summary>
    public long MaxMemorySize { get; set; } = 100 * 1024 * 1024; // 100MB
    
    /// <summary>
    /// 默认过期时间
    /// </summary>
    public TimeSpan DefaultExpiration { get; set; } = TimeSpan.FromHours(1);
    
    /// <summary>
    /// 内存压力阈值（0.0-1.0）
    /// </summary>
    public double MemoryPressureThreshold { get; set; } = 0.8; // 80%
    
    /// <summary>
    /// 清理间隔
    /// </summary>
    public TimeSpan CleanupInterval { get; set; } = TimeSpan.FromMinutes(5);
    
    /// <summary>
    /// 是否启用自动清理
    /// </summary>
    public bool EnableAutoCleanup { get; set; } = true;
    
    /// <summary>
    /// 是否启用性能监控
    /// </summary>
    public bool EnablePerformanceMonitoring { get; set; } = true;
    
    /// <summary>
    /// 最大缓存项数量
    /// </summary>
    public int MaxCacheItems { get; set; } = 1000;
}
```

### 4.3 事件定义

#### 4.3.1 MemoryPressureEvent.cs

```csharp
using MF.Infrastructure.Abstractions.Core.EventBus;

namespace MF.Events.ResourceManagement;

/// <summary>
/// 内存压力事件
/// </summary>
public class MemoryPressureEvent : EventBase
{
    /// <summary>
    /// 当前内存使用量（字节）
    /// </summary>
    public long CurrentMemoryUsage { get; }
    
    /// <summary>
    /// 内存使用百分比
    /// </summary>
    public double UsagePercentage { get; }
    
    /// <summary>
    /// 压力级别
    /// </summary>
    public MemoryPressureLevel PressureLevel { get; }
    
    /// <summary>
    /// 构造函数
    /// </summary>
    /// <param name="currentMemoryUsage">当前内存使用量</param>
    /// <param name="usagePercentage">使用百分比</param>
    /// <param name="pressureLevel">压力级别</param>
    public MemoryPressureEvent(long currentMemoryUsage, double usagePercentage, MemoryPressureLevel pressureLevel)
        : base("ResourceManager")
    {
        CurrentMemoryUsage = currentMemoryUsage;
        UsagePercentage = usagePercentage;
        PressureLevel = pressureLevel;
    }
}

/// <summary>
/// 内存压力级别
/// </summary>
public enum MemoryPressureLevel
{
    /// <summary>
    /// 正常
    /// </summary>
    Normal,
    
    /// <summary>
    /// 警告
    /// </summary>
    Warning,
    
    /// <summary>
    /// 严重
    /// </summary>
    Critical
}
```

#### 4.3.2 CacheCleanupEvent.cs

```csharp
using MF.Infrastructure.Abstractions.Core.EventBus;

namespace MF.Events.ResourceManagement;

/// <summary>
/// 缓存清理事件
/// </summary>
public class CacheCleanupEvent : EventBase
{
    /// <summary>
    /// 清理原因
    /// </summary>
    public CacheCleanupReason Reason { get; }
    
    /// <summary>
    /// 清理前项目数量
    /// </summary>
    public int ItemsBeforeCleanup { get; }
    
    /// <summary>
    /// 清理后项目数量
    /// </summary>
    public int ItemsAfterCleanup { get; }
    
    /// <summary>
    /// 释放的内存大小（字节）
    /// </summary>
    public long MemoryFreed { get; }
    
    /// <summary>
    /// 构造函数
    /// </summary>
    /// <param name="reason">清理原因</param>
    /// <param name="itemsBeforeCleanup">清理前项目数量</param>
    /// <param name="itemsAfterCleanup">清理后项目数量</param>
    /// <param name="memoryFreed">释放的内存大小</param>
    public CacheCleanupEvent(CacheCleanupReason reason, int itemsBeforeCleanup, int itemsAfterCleanup, long memoryFreed)
        : base("CacheService")
    {
        Reason = reason;
        ItemsBeforeCleanup = itemsBeforeCleanup;
        ItemsAfterCleanup = itemsAfterCleanup;
        MemoryFreed = memoryFreed;
    }
}

/// <summary>
/// 缓存清理原因
/// </summary>
public enum CacheCleanupReason
{
    /// <summary>
    /// 内存压力
    /// </summary>
    MemoryPressure,
    
    /// <summary>
    /// 定时清理
    /// </summary>
    Scheduled,
    
    /// <summary>
    /// 手动清理
    /// </summary>
    Manual,
    
    /// <summary>
    /// 过期清理
    /// </summary>
    Expiration
}
```

## 5. 主组件实现

### 5.1 ResourceManager.cs

```csharp
using MF.Infrastructure.Abstractions.Core.Caching;
using MF.Infrastructure.Abstractions.Core.EventBus;
using MF.Infrastructure.Abstractions.Core.Monitoring;
using MF.Services.Abstractions.Core.ResourceManagement;
using MF.Services.Abstractions.Core.ResourceManagement.Models;
using MF.Events.ResourceManagement;

namespace MF.Services.Core.ResourceManagement;

/// <summary>
/// 资源管理器 - 系统核心协调组件
/// </summary>
public class ResourceManager : IResourceCacheService, IResourceMonitorService, IDisposable
{
    private readonly ICacheService _cacheService;
    private readonly IMemoryMonitor _memoryMonitor;
    private readonly IPerformanceMonitor _performanceMonitor;
    private readonly IEventBus _eventBus;
    private readonly ResourceSystemConfig _config;
    
    private readonly Timer _cleanupTimer;
    private readonly object _lockObject = new();
    private bool _disposed;
    
    // 统计数据
    private int _hitCount;
    private int _missCount;
    private int _totalRequests;
    private readonly List<TimeSpan> _responseTimes = new();
    
    public ResourceManager(
        ICacheService cacheService,
        IMemoryMonitor memoryMonitor,
        IPerformanceMonitor performanceMonitor,
        IEventBus eventBus,
        ResourceSystemConfig config)
    {
        _cacheService = cacheService;
        _memoryMonitor = memoryMonitor;
        _performanceMonitor = performanceMonitor;
        _eventBus = eventBus;
        _config = config;
        
        // 订阅内存监控事件
        _memoryMonitor.MemoryPressureDetected += OnMemoryPressureDetected;
        
        // 启动定时清理
        if (_config.EnableAutoCleanup)
        {
            _cleanupTimer = new Timer(OnCleanupTimer, null, _config.CleanupInterval, _config.CleanupInterval);
        }
        
        // 启动内存监控
        _memoryMonitor.StartMonitoring();
    }
    
    #region IResourceCacheService Implementation
    
    public async Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default) where T : class
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            var result = await _cacheService.GetAsync<T>(key, cancellationToken);
            
            lock (_lockObject)
            {
                _totalRequests++;
                if (result != null)
                {
                    _hitCount++;
                }
                else
                {
                    _missCount++;
                }
                _responseTimes.Add(stopwatch.Elapsed);
            }
            
            // 记录性能指标
            if (_config.EnablePerformanceMonitoring)
            {
                _performanceMonitor.RecordTimer("resource_cache_get", stopwatch.Elapsed, 
                    new Dictionary<string, string> { { "hit", (result != null).ToString() } });
            }
            
            return result;
        }
        finally
        {
            stopwatch.Stop();
        }
    }
    
    public async Task SetAsync<T>(string key, T resource, TimeSpan? expiration = null, CancellationToken cancellationToken = default) where T : class
    {
        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
        
        try
        {
            var actualExpiration = expiration ?? _config.DefaultExpiration;
            await _cacheService.SetAsync(key, resource, actualExpiration, cancellationToken);
            
            // 记录性能指标
            if (_config.EnablePerformanceMonitoring)
            {
                _performanceMonitor.RecordTimer("resource_cache_set", stopwatch.Elapsed);
                _performanceMonitor.RecordCounter("resource_cache_items_added");
            }
        }
        finally
        {
            stopwatch.Stop();
        }
    }
    
    public async Task RemoveAsync(string key, CancellationToken cancellationToken = default)
    {
        await _cacheService.RemoveAsync(key, cancellationToken);
        
        if (_config.EnablePerformanceMonitoring)
        {
            _performanceMonitor.RecordCounter("resource_cache_items_removed");
        }
    }
    
    public async Task CleanupAsync(CancellationToken cancellationToken = default)
    {
        await PerformCleanup(CacheCleanupReason.Manual);
    }
    
    public async Task<bool> ExistsAsync(string key, CancellationToken cancellationToken = default)
    {
        return await _cacheService.ExistsAsync(key, cancellationToken);
    }
    
    #endregion
    
    #region IResourceMonitorService Implementation
    
    public async Task<CacheStatistics> GetCacheStatisticsAsync(CancellationToken cancellationToken = default)
    {
        lock (_lockObject)
        {
            return new CacheStatistics
            {
                HitCount = _hitCount,
                MissCount = _missCount,
                TotalItems = 0, // 需要从缓存服务获取
                TotalSize = 0,  // 需要从缓存服务获取
                LastUpdated = DateTime.UtcNow
            };
        }
    }
    
    public async Task<MemoryUsage> GetMemoryUsageAsync(CancellationToken cancellationToken = default)
    {
        var currentUsage = _memoryMonitor.GetCurrentMemoryUsage();
        var maxUsage = _config.MaxMemorySize;
        
        return new MemoryUsage
        {
            CurrentUsage = currentUsage,
            MaxUsage = maxUsage,
            UsagePercentage = maxUsage > 0 ? (double)currentUsage / maxUsage : 0,
            AvailableMemory = Math.Max(0, maxUsage - currentUsage),
            GCCollectionCount = GC.CollectionCount(0) + GC.CollectionCount(1) + GC.CollectionCount(2),
            LastChecked = DateTime.UtcNow
        };
    }
    
    public async Task<PerformanceReport> GetPerformanceReportAsync(TimeSpan period, CancellationToken cancellationToken = default)
    {
        var cacheStats = await GetCacheStatisticsAsync(cancellationToken);
        var memoryStats = await GetMemoryUsageAsync(cancellationToken);
        
        lock (_lockObject)
        {
            var avgResponseTime = _responseTimes.Count > 0 
                ? TimeSpan.FromTicks((long)_responseTimes.Average(t => t.Ticks))
                : TimeSpan.Zero;
                
            var fastestTime = _responseTimes.Count > 0 
                ? _responseTimes.Min()
                : TimeSpan.Zero;
                
            var slowestTime = _responseTimes.Count > 0 
                ? _responseTimes.Max()
                : TimeSpan.Zero;
            
            return new PerformanceReport
            {
                Period = period,
                CacheStats = cacheStats,
                MemoryStats = memoryStats,
                TotalRequests = _totalRequests,
                AverageResponseTime = avgResponseTime,
                FastestResponseTime = fastestTime,
                SlowestResponseTime = slowestTime,
                ErrorCount = 0, // 需要实现错误计数
                GeneratedAt = DateTime.UtcNow
            };
        }
    }
    
    public async Task<ResourceSystemConfig> GetConfigurationAsync(CancellationToken cancellationToken = default)
    {
        return _config;
    }
    
    public async Task UpdateConfigurationAsync(ResourceSystemConfig config, CancellationToken cancellationToken = default)
    {
        // 更新配置逻辑
        _config.MaxMemorySize = config.MaxMemorySize;
        _config.DefaultExpiration = config.DefaultExpiration;
        _config.MemoryPressureThreshold = config.MemoryPressureThreshold;
        _config.CleanupInterval = config.CleanupInterval;
        _config.EnableAutoCleanup = config.EnableAutoCleanup;
        _config.EnablePerformanceMonitoring = config.EnablePerformanceMonitoring;
        _config.MaxCacheItems = config.MaxCacheItems;
        
        // 更新内存监控器配置
        _memoryMonitor.MemoryPressureThreshold = config.MemoryPressureThreshold;
    }
    
    #endregion
    
    #region Event Handlers
    
    private async void OnMemoryPressureDetected(long currentUsage)
    {
        var usagePercentage = _config.MaxMemorySize > 0 ? (double)currentUsage / _config.MaxMemorySize : 0;
        var pressureLevel = GetPressureLevel(usagePercentage);
        
        // 发布内存压力事件
        await _eventBus.PublishAsync(new MemoryPressureEvent(currentUsage, usagePercentage, pressureLevel));
        
        // 根据压力级别执行清理
        if (pressureLevel >= MemoryPressureLevel.Warning)
        {
            await PerformCleanup(CacheCleanupReason.MemoryPressure);
        }
    }
    
    private async void OnCleanupTimer(object? state)
    {
        await PerformCleanup(CacheCleanupReason.Scheduled);
    }
    
    #endregion
    
    #region Private Methods
    
    private async Task PerformCleanup(CacheCleanupReason reason)
    {
        try
        {
            // 执行清理逻辑
            // 这里需要实现具体的清理策略
            
            // 发布清理事件
            await _eventBus.PublishAsync(new CacheCleanupEvent(reason, 0, 0, 0));
            
            if (_config.EnablePerformanceMonitoring)
            {
                _performanceMonitor.RecordCounter("cache_cleanup_performed", 1, 
                    new Dictionary<string, string> { { "reason", reason.ToString() } });
            }
        }
        catch (Exception ex)
        {
            // 记录错误
            if (_config.EnablePerformanceMonitoring)
            {
                _performanceMonitor.RecordCounter("cache_cleanup_errors");
            }
        }
    }
    
    private static MemoryPressureLevel GetPressureLevel(double usagePercentage)
    {
        return usagePercentage switch
        {
            >= 0.9 => MemoryPressureLevel.Critical,
            >= 0.8 => MemoryPressureLevel.Warning,
            _ => MemoryPressureLevel.Normal
        };
    }
    
    #endregion
    
    #region IDisposable
    
    public void Dispose()
    {
        if (_disposed) return;
        
        _cleanupTimer?.Dispose();
        _memoryMonitor?.StopMonitoring();
        _memoryMonitor.MemoryPressureDetected -= OnMemoryPressureDetected;
        
        _disposed = true;
    }
    
    #endregion
}
```

## 6. 依赖注入配置

### 6.1 ServiceCollectionExtensions.cs

```csharp
using Microsoft.Extensions.DependencyInjection;
using MF.Services.Abstractions.Core.ResourceManagement;
using MF.Services.Abstractions.Core.ResourceManagement.Models;
using MF.Services.Core.ResourceManagement;

namespace MF.Services.Extensions;

/// <summary>
/// 资源管理系统服务注册扩展
/// </summary>
public static class ResourceManagementServiceExtensions
{
    /// <summary>
    /// 添加资源管理系统服务
    /// </summary>
    /// <param name="services">服务集合</param>
    /// <param name="configureOptions">配置选项</param>
    /// <returns>服务集合</returns>
    public static IServiceCollection AddResourceManagement(
        this IServiceCollection services,
        Action<ResourceSystemConfig>? configureOptions = null)
    {
        // 注册配置
        var config = new ResourceSystemConfig();
        configureOptions?.Invoke(config);
        services.AddSingleton(config);
        
        // 注册主组件
        services.AddSingleton<ResourceManager>();
        
        // 注册接口
        services.AddSingleton<IResourceCacheService>(provider => provider.GetRequiredService<ResourceManager>());
        services.AddSingleton<IResourceMonitorService>(provider => provider.GetRequiredService<ResourceManager>());
        
        return services;
    }
}
```

## 7. 集成现有资源加载器

### 7.1 扩展现有 IResourceLoader

在 `MF.Services/ResourceLoading/` 中修改现有的资源加载器实现，集成新的缓存服务：

```csharp
// 在现有的 ResourceLoader 实现中
public class GodotResourceLoader : IResourceLoader
{
    private readonly IResourceCacheService _cacheService;
    // ... 其他依赖
    
    public async Task<T?> LoadAsync<T>(string path, CancellationToken cancellationToken = default) where T : class
    {
        // 1. 尝试从新的缓存服务获取
        var cached = await _cacheService.GetAsync<T>(path, cancellationToken);
        if (cached != null) return cached;
        
        // 2. 加载资源
        var resource = await LoadFromDiskAsync<T>(path, cancellationToken);
        
        // 3. 存储到新的缓存服务
        if (resource != null)
        {
            await _cacheService.SetAsync(path, resource, cancellationToken: cancellationToken);
        }
        
        return resource;
    }
    
    // ... 其他方法实现
}
```

## 8. 实施步骤

### 8.1 第一阶段：基础接口和模型

1. 创建 `MF.Services.Abstractions/Core/ResourceManagement/` 目录
2. 实现所有接口和数据模型
3. 创建事件定义

### 8.2 第二阶段：核心组件实现

1. 创建 `MF.Services/Core/ResourceManagement/` 目录
2. 实现 `ResourceManager` 主组件
3. 实现依赖注入扩展

### 8.3 第三阶段：集成现有系统

1. 修改现有的 `IResourceLoader` 实现
2. 更新项目引用和依赖
3. 添加配置和初始化代码

### 8.4 第四阶段：测试和优化

1. 编写单元测试
2. 集成测试
3. 性能测试和优化

## 9. 配置示例

### 9.1 在 AutoLoad 中初始化

```csharp
// 在 AutoLoad 脚本中
public override void _Ready()
{
    var services = new ServiceCollection();
    
    // 添加基础设施服务
    services.AddSingleton<ICacheService, MemoryCacheService>();
    services.AddSingleton<IMemoryMonitor, GodotMemoryMonitor>();
    services.AddSingleton<IPerformanceMonitor, DefaultPerformanceMonitor>();
    services.AddSingleton<IEventBus, InMemoryEventBus>();
    
    // 添加资源管理系统
    services.AddResourceManagement(config =>
    {
        config.MaxMemorySize = 200 * 1024 * 1024; // 200MB
        config.DefaultExpiration = TimeSpan.FromMinutes(30);
        config.MemoryPressureThreshold = 0.75; // 75%
        config.CleanupInterval = TimeSpan.FromMinutes(3);
    });
    
    var serviceProvider = services.BuildServiceProvider();
    
    // 获取服务实例
    var resourceManager = serviceProvider.GetRequiredService<ResourceManager>();
}
```

## 10. 总结

本实现方案基于现有的 ModularGodot 框架架构，充分利用了现有的基础设施接口，实现了：

1. **架构一致性**：遵循现有的分层架构和命名约定
2. **接口复用**：最大化利用现有的 `ICacheService`、`IMemoryMonitor` 等接口
3. **事件驱动**：使用现有的事件总线实现组件间解耦
4. **依赖注入**：符合现有的 DI 模式
5. **渐进集成**：可以逐步集成到现有系统中

通过这种设计，资源管理监控系统能够无缝集成到现有框架中，为整个系统提供统一、高效的资源管理和监控能力。