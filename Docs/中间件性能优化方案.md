# 中间件性能优化方案

## 性能考虑分析

你的担心是完全合理的！中间件确实会带来一定的性能开销，但这个开销是否可接受需要具体分析。让我们深入探讨这个问题。

## 性能开销来源分析

### 1. MediatR性能开销

#### A. 反射开销
```csharp
// MediatR内部的处理器查找（简化版）
public async Task<TResponse> Send<TResponse>(IRequest<TResponse> request)
{
    var requestType = request.GetType();
    var handlerType = typeof(IRequestHandler<,>).MakeGenericType(requestType, typeof(TResponse));
    var handler = _serviceProvider.GetService(handlerType); // 反射查找
    
    // 反射调用
    var method = handlerType.GetMethod("Handle");
    return await (Task<TResponse>)method.Invoke(handler, new object[] { request });
}
```

**开销分析**：
- 类型查找：~0.1-0.5μs
- 服务解析：~0.5-2μs
- 反射调用：~1-5μs
- **总计**：~1.6-7.5μs per command

#### B. 对象分配开销
```csharp
// 每个命令都会创建新对象
public record MovePlayerCommand(string PlayerId, Vector2 Direction, float Speed) : GameCommand;

// 每次调用都会分配：
// - 命令对象：~200-500 bytes
// - 任务对象：~100-200 bytes
// - 委托对象：~50-100 bytes
```

**开销分析**：
- 对象分配：~350-800 bytes per command
- GC压力：取决于调用频率

### 2. 事件总线性能开销

#### A. 事件分发开销
```csharp
public async Task PublishAsync<T>(T @event) where T : IGameEvent
{
    // 查找订阅者：O(1) - Dictionary查找
    if (!_subscriptions.TryGetValue(typeof(T), out var subscriptions))
        return;
    
    // 创建任务列表：O(n) - n为订阅者数量
    var tasks = new List<Task>();
    foreach (var subscription in subscriptions)
    {
        tasks.Add(subscription.HandleAsync(@event)); // 每个订阅者一个Task
    }
    
    // 并行等待：O(1) - 但有线程切换开销
    await Task.WhenAll(tasks);
}
```

**开销分析**：
- 订阅者查找：~0.1μs
- 任务创建：~1-2μs per subscriber
- 并行执行：~5-20μs (线程切换)
- **总计**：~5-25μs per event (取决于订阅者数量)

## 性能基准测试

### 1. 测试场景设计

```csharp
// 性能测试基准
[MemoryDiagnoser]
[SimpleJob(RuntimeMoniker.Net90)]
public class ArchitecturePerformanceBenchmark
{
    private IMediator _mediator;
    private IEventBus _eventBus;
    private DirectCallService _directService;
    
    [GlobalSetup]
    public void Setup()
    {
        // 初始化测试环境
        var services = new ServiceCollection();
        services.AddMediatR(typeof(MovePlayerCommand));
        services.AddSingleton<IEventBus, EventBus>();
        services.AddSingleton<DirectCallService>();
        
        var provider = services.BuildServiceProvider();
        _mediator = provider.GetService<IMediator>();
        _eventBus = provider.GetService<IEventBus>();
        _directService = provider.GetService<DirectCallService>();
    }
    
    [Benchmark(Baseline = true)]
    public async Task DirectCall()
    {
        // 直接调用基准
        await _directService.MovePlayerAsync("Player1", Vector2.Right, 300f);
    }
    
    [Benchmark]
    public async Task MediatRCommand()
    {
        // MediatR命令调用
        await _mediator.Send(new MovePlayerCommand("Player1", Vector2.Right, 300f));
    }
    
    [Benchmark]
    public async Task EventBusPublish()
    {
        // 事件总线发布
        await _eventBus.PublishAsync(new PlayerMovedEvent
        {
            PlayerId = "Player1",
            NewPosition = Vector2.Right * 300f
        });
    }
    
    [Benchmark]
    public async Task FullCQRSFlow()
    {
        // 完整的CQRS流程
        await _mediator.Send(new MovePlayerCommand("Player1", Vector2.Right, 300f));
        // 命令处理器内部会发布事件
    }
}
```

### 2. 预期性能结果

```
|        Method |      Mean |    Error |   StdDev |  Gen 0 | Allocated |
|-------------- |----------:|---------:|---------:|-------:|----------:|
|    DirectCall |  1.234 μs | 0.012 μs | 0.011 μs | 0.0019 |     120 B |
| MediatRCommand|  8.567 μs | 0.089 μs | 0.083 μs | 0.0153 |     960 B |
| EventBusPublish| 12.345 μs | 0.156 μs | 0.146 μs | 0.0305 |   1,920 B |
|  FullCQRSFlow | 23.456 μs | 0.234 μs | 0.219 μs | 0.0610 |   3,840 B |
```

**分析**：
- MediatR开销：~7x 直接调用
- 事件总线开销：~10x 直接调用
- 完整CQRS流程：~19x 直接调用

## 性能优化策略

### 1. MediatR优化

#### A. 预编译处理器查找
```csharp
// 使用源生成器预编译处理器映射
[SourceGenerator]
public class MediatRSourceGenerator : ISourceGenerator
{
    public void Execute(GeneratorExecutionContext context)
    {
        // 生成静态处理器映射
        var code = @"
public static class CompiledHandlerMap
{
    private static readonly Dictionary<Type, Func<object, IServiceProvider, Task<object>>> Handlers = new()
    {
        { typeof(MovePlayerCommand), async (cmd, sp) => 
        {
            var handler = sp.GetService<MovePlayerCommandHandler>();
            await handler.Handle((MovePlayerCommand)cmd, CancellationToken.None);
            return null;
        }},
        // ... 其他处理器
    };
    
    public static async Task<TResponse> SendAsync<TResponse>(IRequest<TResponse> request, IServiceProvider serviceProvider)
    {
        if (Handlers.TryGetValue(request.GetType(), out var handler))
        {
            return (TResponse)await handler(request, serviceProvider);
        }
        throw new InvalidOperationException($"No handler found for {request.GetType()}");
    }
}
";
        context.AddSource("CompiledHandlerMap.g.cs", code);
    }
}

// 优化后的MediatR实现
public class OptimizedMediator : IMediator
{
    private readonly IServiceProvider _serviceProvider;
    
    public async Task<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken = default)
    {
        // 使用预编译的处理器映射，避免反射
        return await CompiledHandlerMap.SendAsync(request, _serviceProvider);
    }
}
```

**性能提升**：~3-5x faster than reflection-based MediatR

#### B. 对象池优化
```csharp
// 命令对象池
public class CommandObjectPool<T> where T : class, new()
{
    private readonly ConcurrentQueue<T> _objects = new();
    private readonly Func<T> _objectGenerator;
    
    public CommandObjectPool(Func<T> objectGenerator = null)
    {
        _objectGenerator = objectGenerator ?? (() => new T());
    }
    
    public T Get()
    {
        if (_objects.TryDequeue(out var item))
            return item;
        return _objectGenerator();
    }
    
    public void Return(T item)
    {
        // 重置对象状态
        if (item is IResettable resettable)
            resettable.Reset();
        
        _objects.Enqueue(item);
    }
}

// 可重用的命令基类
public abstract class PoolableCommand : GameCommand, IResettable
{
    public virtual void Reset()
    {
        // 重置命令状态
        Source = "Unknown";
    }
}

// 使用对象池的命令
public class MovePlayerCommand : PoolableCommand
{
    public string PlayerId { get; set; }
    public Vector2 Direction { get; set; }
    public float Speed { get; set; }
    
    public override void Reset()
    {
        base.Reset();
        PlayerId = null;
        Direction = Vector2.Zero;
        Speed = 0f;
    }
    
    // 静态工厂方法
    private static readonly CommandObjectPool<MovePlayerCommand> Pool = new();
    
    public static MovePlayerCommand Create(string playerId, Vector2 direction, float speed)
    {
        var cmd = Pool.Get();
        cmd.PlayerId = playerId;
        cmd.Direction = direction;
        cmd.Speed = speed;
        return cmd;
    }
    
    public void Dispose()
    {
        Pool.Return(this);
    }
}
```

**性能提升**：减少GC压力，提升~20-30%性能

### 2. 事件总线优化

#### A. 高性能事件分发
```csharp
public class OptimizedEventBus : IEventBus
{
    // 使用更高效的数据结构
    private readonly ConcurrentDictionary<Type, FastSubscriptionList> _subscriptions = new();
    
    // 自定义高性能订阅列表
    private class FastSubscriptionList
    {
        private volatile IEventSubscription[] _subscriptions = Array.Empty<IEventSubscription>();
        private readonly ReaderWriterLockSlim _lock = new();
        
        public void Add(IEventSubscription subscription)
        {
            _lock.EnterWriteLock();
            try
            {
                var newArray = new IEventSubscription[_subscriptions.Length + 1];
                Array.Copy(_subscriptions, newArray, _subscriptions.Length);
                newArray[_subscriptions.Length] = subscription;
                _subscriptions = newArray; // 原子替换
            }
            finally
            {
                _lock.ExitWriteLock();
            }
        }
        
        public async Task PublishAsync<T>(T @event) where T : IGameEvent
        {
            var subscriptions = _subscriptions; // 获取快照，避免锁
            
            if (subscriptions.Length == 0)
                return;
            
            if (subscriptions.Length == 1)
            {
                // 单订阅者优化：直接调用，避免Task.WhenAll开销
                await subscriptions[0].HandleAsync(@event, CancellationToken.None);
                return;
            }
            
            // 多订阅者：使用ValueTask优化
            var tasks = new ValueTask[subscriptions.Length];
            for (int i = 0; i < subscriptions.Length; i++)
            {
                tasks[i] = new ValueTask(subscriptions[i].HandleAsync(@event, CancellationToken.None));
            }
            
            // 等待所有任务完成
            for (int i = 0; i < tasks.Length; i++)
            {
                await tasks[i];
            }
        }
    }
    
    public async Task PublishAsync<T>(T @event, CancellationToken cancellationToken = default) where T : IGameEvent
    {
        if (_subscriptions.TryGetValue(typeof(T), out var subscriptionList))
        {
            await subscriptionList.PublishAsync(@event);
        }
    }
}
```

**性能提升**：~2-3x faster event publishing

#### B. 批量事件处理
```csharp
// 批量事件处理器
public class BatchEventProcessor : IDisposable
{
    private readonly Channel<IGameEvent> _eventChannel;
    private readonly IEventBus _eventBus;
    private readonly Task _processingTask;
    private readonly CancellationTokenSource _cancellationTokenSource;
    
    public BatchEventProcessor(IEventBus eventBus, int batchSize = 100, int flushIntervalMs = 16)
    {
        _eventBus = eventBus;
        _cancellationTokenSource = new CancellationTokenSource();
        
        var options = new BoundedChannelOptions(10000)
        {
            FullMode = BoundedChannelFullMode.Wait,
            SingleReader = true,
            SingleWriter = false
        };
        
        _eventChannel = Channel.CreateBounded<IGameEvent>(options);
        _processingTask = ProcessEventsAsync(batchSize, flushIntervalMs, _cancellationTokenSource.Token);
    }
    
    public async Task PublishAsync<T>(T @event) where T : IGameEvent
    {
        await _eventChannel.Writer.WriteAsync(@event);
    }
    
    private async Task ProcessEventsAsync(int batchSize, int flushIntervalMs, CancellationToken cancellationToken)
    {
        var batch = new List<IGameEvent>(batchSize);
        var timer = Stopwatch.StartNew();
        
        await foreach (var @event in _eventChannel.Reader.ReadAllAsync(cancellationToken))
        {
            batch.Add(@event);
            
            // 批量处理条件：达到批量大小或超时
            if (batch.Count >= batchSize || timer.ElapsedMilliseconds >= flushIntervalMs)
            {
                await ProcessBatchAsync(batch);
                batch.Clear();
                timer.Restart();
            }
        }
    }
    
    private async Task ProcessBatchAsync(List<IGameEvent> events)
    {
        // 按事件类型分组，减少类型查找开销
        var eventGroups = events.GroupBy(e => e.GetType());
        
        var tasks = eventGroups.Select(async group =>
        {
            foreach (var @event in group)
            {
                await _eventBus.PublishAsync(@event);
            }
        });
        
        await Task.WhenAll(tasks);
    }
    
    public void Dispose()
    {
        _eventChannel.Writer.Complete();
        _cancellationTokenSource.Cancel();
        _processingTask.Wait(5000);
        _cancellationTokenSource.Dispose();
    }
}
```

**性能提升**：批量处理可提升~40-60%吞吐量

### 3. 智能性能模式

#### A. 性能模式切换
```csharp
public enum PerformanceMode
{
    Development,    // 完整的CQRS，便于调试
    Production,     // 优化的CQRS，平衡性能和架构
    HighPerformance // 直接调用，最高性能
}

public class AdaptiveMediator : IMediator
{
    private readonly IMediator _fullMediator;
    private readonly IMediator _optimizedMediator;
    private readonly IServiceProvider _serviceProvider;
    private readonly PerformanceMode _mode;
    
    public AdaptiveMediator(
        IMediator fullMediator,
        IMediator optimizedMediator,
        IServiceProvider serviceProvider,
        IConfiguration configuration)
    {
        _fullMediator = fullMediator;
        _optimizedMediator = optimizedMediator;
        _serviceProvider = serviceProvider;
        _mode = configuration.GetValue<PerformanceMode>("PerformanceMode");
    }
    
    public async Task<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken = default)
    {
        return _mode switch
        {
            PerformanceMode.Development => await _fullMediator.Send(request, cancellationToken),
            PerformanceMode.Production => await _optimizedMediator.Send(request, cancellationToken),
            PerformanceMode.HighPerformance => await DirectCall(request, cancellationToken),
            _ => await _fullMediator.Send(request, cancellationToken)
        };
    }
    
    private async Task<TResponse> DirectCall<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken)
    {
        // 高性能模式：直接调用服务，跳过中间件
        return request switch
        {
            MovePlayerCommand cmd => (TResponse)(object)await _serviceProvider.GetService<IGameLogicService>()
                .MovePlayerAsync(cmd.PlayerId, cmd.Direction, cmd.Speed),
            AttackCommand cmd => (TResponse)(object)await _serviceProvider.GetService<ICombatService>()
                .ExecuteAttackAsync(cmd.AttackerId, cmd.TargetId, cmd.Damage, cmd.Position),
            _ => await _optimizedMediator.Send(request, cancellationToken)
        };
    }
}
```

#### B. 热路径优化
```csharp
// 识别热路径命令
[HotPath] // 自定义属性标记热路径
public record MovePlayerCommand(string PlayerId, Vector2 Direction, float Speed) : GameCommand;

[HotPath]
public record UpdateHealthCommand(string EntityId, float NewHealth) : GameCommand;

// 热路径优化的中介者
public class HotPathOptimizedMediator : IMediator
{
    private readonly IMediator _standardMediator;
    private readonly ConcurrentDictionary<Type, bool> _hotPathCache = new();
    private readonly IServiceProvider _serviceProvider;
    
    public async Task<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken = default)
    {
        var requestType = request.GetType();
        
        // 检查是否为热路径
        var isHotPath = _hotPathCache.GetOrAdd(requestType, type => 
            type.GetCustomAttribute<HotPathAttribute>() != null);
        
        if (isHotPath)
        {
            // 热路径：使用优化的直接调用
            return await HandleHotPath<TResponse>(request, cancellationToken);
        }
        
        // 非热路径：使用标准MediatR
        return await _standardMediator.Send(request, cancellationToken);
    }
    
    private async Task<TResponse> HandleHotPath<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken)
    {
        // 预编译的热路径处理器映射
        return await HotPathHandlerMap.HandleAsync<TResponse>(request, _serviceProvider, cancellationToken);
    }
}
```

## 性能监控和分析

### 1. 实时性能监控
```csharp
public class PerformanceMonitoringMediator : IMediator
{
    private readonly IMediator _innerMediator;
    private readonly IMetrics _metrics;
    private readonly ILogger<PerformanceMonitoringMediator> _logger;
    
    public async Task<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken = default)
    {
        var stopwatch = Stopwatch.StartNew();
        var commandType = request.GetType().Name;
        
        try
        {
            var result = await _innerMediator.Send(request, cancellationToken);
            
            stopwatch.Stop();
            
            // 记录性能指标
            _metrics.Measure.Timer.Time("command.execution_time", stopwatch.Elapsed, 
                new MetricTags("command_type", commandType));
            
            // 性能警告
            if (stopwatch.ElapsedMicroseconds > 1000) // 超过1ms
            {
                _logger.LogWarning("Slow command execution: {CommandType} took {ElapsedMicroseconds}μs", 
                    commandType, stopwatch.ElapsedMicroseconds);
            }
            
            return result;
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _metrics.Measure.Counter.Increment("command.errors", 
                new MetricTags("command_type", commandType));
            throw;
        }
    }
}
```

### 2. 性能分析报告
```csharp
public class PerformanceAnalyzer
{
    private readonly ConcurrentDictionary<string, PerformanceStats> _stats = new();
    
    public void RecordExecution(string commandType, TimeSpan duration, bool success)
    {
        _stats.AddOrUpdate(commandType, 
            new PerformanceStats { Count = 1, TotalTime = duration, Errors = success ? 0 : 1 },
            (key, existing) => new PerformanceStats
            {
                Count = existing.Count + 1,
                TotalTime = existing.TotalTime + duration,
                Errors = existing.Errors + (success ? 0 : 1)
            });
    }
    
    public PerformanceReport GenerateReport()
    {
        var report = new PerformanceReport();
        
        foreach (var kvp in _stats)
        {
            var stats = kvp.Value;
            var avgTime = stats.TotalTime.TotalMicroseconds / stats.Count;
            
            report.CommandStats.Add(new CommandPerformanceStats
            {
                CommandType = kvp.Key,
                ExecutionCount = stats.Count,
                AverageExecutionTime = TimeSpan.FromMicroseconds(avgTime),
                ErrorRate = (double)stats.Errors / stats.Count,
                TotalTime = stats.TotalTime
            });
        }
        
        // 按平均执行时间排序，找出性能瓶颈
        report.CommandStats = report.CommandStats
            .OrderByDescending(s => s.AverageExecutionTime)
            .ToList();
        
        return report;
    }
}
```

## 性能优化建议

### 1. 分层优化策略

**游戏循环热路径**（60FPS，16.67ms预算）：
- 移动、动画、物理更新：使用直接调用或高度优化的中间件
- 预算：每帧<100个命令，每个命令<10μs

**用户交互路径**（响应时间<100ms）：
- UI交互、菜单操作：使用标准CQRS架构
- 预算：每个操作<1000μs

**后台任务路径**（响应时间<1s）：
- 保存游戏、网络同步：使用完整的CQRS+事件架构
- 预算：每个操作<10000μs

### 2. 具体优化措施

```csharp
// 游戏节点的性能优化实现
public partial class OptimizedPlayerNode : Node
{
    private IMediator _mediator;
    private IGameLogicService _gameLogicService; // 直接引用，用于热路径
    
    // 热路径：直接调用
    public override void _PhysicsProcess(double delta)
    {
        var input = GetMovementInput();
        if (input != Vector2.Zero)
        {
            // 直接调用，避免中间件开销
            _ = _gameLogicService.MovePlayerAsync(Name, input, Speed);
        }
    }
    
    // 冷路径：使用CQRS
    private async void OnAttackButtonPressed()
    {
        // 使用中间件，保持架构清晰
        await _mediator.Send(new AttackCommand(Name, _targetId, _damage, _position));
    }
    
    // 配置路径：使用完整架构
    private async void OnSettingsChanged()
    {
        await _mediator.Send(new UpdatePlayerSettingsCommand(Name, _newSettings));
    }
}
```

### 3. 性能基准目标

| 场景 | 目标延迟 | 目标吞吐量 | 内存分配 |
|------|----------|------------|----------|
| 移动命令 | <10μs | >100k/s | <200B |
| UI交互 | <100μs | >10k/s | <1KB |
| 游戏保存 | <10ms | >100/s | <10KB |
| 网络同步 | <50ms | >1k/s | <5KB |

## 总结和建议

### 性能vs架构权衡

1. **开发阶段**：使用完整CQRS架构，便于调试和维护
2. **测试阶段**：引入性能监控，识别瓶颈
3. **优化阶段**：对热路径进行针对性优化
4. **生产阶段**：使用混合模式，平衡性能和架构

### 实施建议

1. **先实现架构**：确保代码结构清晰和可维护
2. **后优化性能**：基于实际测试数据进行优化
3. **分层优化**：不同路径使用不同的性能策略
4. **持续监控**：建立性能监控和报警机制

**结论**：中间件确实会带来性能开销，但通过合理的优化策略，可以在保持架构清晰性的同时实现可接受的性能。关键是要根据具体场景选择合适的优化级别。