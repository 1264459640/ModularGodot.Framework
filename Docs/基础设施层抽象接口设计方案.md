# 基础设施层抽象接口设计方案

## 问题分析

你提出了一个重要的架构设计问题：**基础设施层是否需要抽象接口层？**

这个问题涉及到技术抽象的程度、可测试性、可替换性、性能开销等多个方面的权衡。基于我们之前讨论的 <mcfile name="仓储层模块迁移方案.md" path="d:\GodotProjects\ModularGodot\仓储层模块迁移方案.md"></mcfile> 和其他架构重构方案，让我们深入分析基础设施层抽象接口的必要性和设计策略。

## 基础设施层的特殊性

### 1. 基础设施层的职责

基础设施层负责提供技术服务和横切关注点：

```csharp
// 基础设施层的典型服务
MF.Infrastructure/
├── EventBus/           // 事件总线
├── Logging/            // 日志系统
├── Caching/            // 缓存系统
├── Monitoring/         // 监控系统
├── ResourceLoading/    // 资源加载
├── Serialization/      // 序列化
├── FileSystem/         // 文件系统
├── Network/            // 网络通信
├── Database/           // 数据库访问
└── Configuration/      // 配置管理
```

### 2. 基础设施层与其他层的区别

| 层次 | 抽象需求 | 变化频率 | 技术依赖 | 测试复杂度 |
|------|----------|----------|----------|------------|
| **领域层** | 高 | 低 | 无 | 低 |
| **应用层** | 中 | 中 | 低 | 中 |
| **基础设施层** | **?** | **高** | **高** | **高** |

**基础设施层的特点**：
- **技术密集**：直接与具体技术打交道
- **变化频繁**：技术栈可能需要升级或替换
- **性能敏感**：往往是系统的性能瓶颈
- **测试困难**：涉及外部依赖（文件、网络、数据库等）

## 抽象策略分析

### 策略1：完全抽象（传统DDD方法）

```csharp
// ✅ 优势：完全解耦，易于测试
// ❌ 劣势：过度抽象，性能开销

// 抽象接口
public interface IEventBus
{
    Task PublishAsync<T>(T @event) where T : IEvent;
    IDisposable Subscribe<T>(Action<T> handler) where T : IEvent;
}

public interface ILogger
{
    void LogInformation(string message, params object[] args);
    void LogError(Exception exception, string message, params object[] args);
}

public interface ICacheService
{
    Task<T?> GetAsync<T>(string key) where T : class;
    Task SetAsync<T>(string key, T value, TimeSpan? expiration = null) where T : class;
}

// 具体实现
public class R3EventBus : IEventBus { /* 实现 */ }
public class SerilogLogger : ILogger { /* 实现 */ }
public class RedisCacheService : ICacheService { /* 实现 */ }
```

**优势**：
- ✅ 完全解耦，上层不依赖具体技术
- ✅ 易于单元测试（Mock接口）
- ✅ 易于替换实现
- ✅ 符合依赖倒置原则

**劣势**：
- ❌ 抽象开销（虚函数调用）
- ❌ 可能过度抽象
- ❌ 接口设计复杂
- ❌ 运行时类型检查开销

### 策略2：选择性抽象（实用主义方法）

```csharp
// ✅ 优势：平衡抽象和性能
// ❌ 劣势：需要仔细权衡

// 高变化可能性的服务：使用接口
public interface IEventBus
{
    Task PublishAsync<T>(T @event) where T : IEvent;
    IDisposable Subscribe<T>(Action<T> handler) where T : IEvent;
}

public interface ICacheService
{
    Task<T?> GetAsync<T>(string key) where T : class;
    Task SetAsync<T>(string key, T value, TimeSpan? expiration = null) where T : class;
}

// 低变化可能性的服务：直接使用具体类
public class GodotFileSystem
{
    public async Task<string> ReadAllTextAsync(string path) { /* 实现 */ }
    public async Task WriteAllTextAsync(string path, string content) { /* 实现 */ }
}

public class JsonSerializer
{
    public string Serialize<T>(T obj) { /* 实现 */ }
    public T? Deserialize<T>(string json) { /* 实现 */ }
}
```

**优势**：
- ✅ 平衡了抽象和性能
- ✅ 减少了不必要的抽象
- ✅ 保持了关键服务的可替换性
- ✅ 降低了复杂度

**劣势**：
- ❌ 需要仔细判断哪些需要抽象
- ❌ 可能导致架构不一致
- ❌ 部分服务难以测试

### 策略3：最小抽象（性能优先方法）

```csharp
// ✅ 优势：最佳性能
// ❌ 劣势：紧耦合，难以测试

// 直接使用具体实现
public class R3EventBus
{
    public Task PublishAsync<T>(T @event) where T : IEvent { /* 实现 */ }
    public IDisposable Subscribe<T>(Action<T> handler) where T : IEvent { /* 实现 */ }
}

public class GodotLogger
{
    public void LogInformation(string message, params object[] args) { /* 实现 */ }
    public void LogError(Exception exception, string message, params object[] args) { /* 实现 */ }
}

public class MemoryCacheService
{
    public Task<T?> GetAsync<T>(string key) where T : class { /* 实现 */ }
    public Task SetAsync<T>(string key, T value, TimeSpan? expiration = null) where T : class { /* 实现 */ }
}
```

**优势**：
- ✅ 最佳性能（无虚函数调用）
- ✅ 简单直接
- ✅ 无抽象开销
- ✅ 编译时优化

**劣势**：
- ❌ 紧耦合到具体技术
- ❌ 难以单元测试
- ❌ 难以替换实现
- ❌ 违反依赖倒置原则

## 推荐方案：分层抽象策略

基于游戏开发的特殊需求和我们的架构重构目标，我推荐采用**分层抽象策略**：

### 1. 抽象分级原则

```csharp
// 抽象级别定义
public enum AbstractionLevel
{
    Critical,    // 必须抽象：高变化可能性，核心业务依赖
    Standard,    // 选择抽象：中等变化可能性，重要但非核心
    Minimal      // 最小抽象：低变化可能性，性能敏感
}
```

### 2. 具体分级策略

#### A. Critical级别：必须抽象

**特征**：
- 高变化可能性
- 核心业务强依赖
- 需要多种实现
- 测试重要性高

```csharp
// ✅ Critical级别：事件总线
namespace MF.Infrastructure.Abstractions.EventBus
{
    /// <summary>
    /// 事件总线抽象接口
    /// </summary>
    public interface IEventBus
    {
        /// <summary>
        /// 异步发布事件
        /// </summary>
        Task PublishAsync<TEvent>(TEvent @event, CancellationToken cancellationToken = default) where TEvent : IEvent;
        
        /// <summary>
        /// 同步发布事件
        /// </summary>
        void Publish<TEvent>(TEvent @event) where TEvent : IEvent;
        
        /// <summary>
        /// 订阅事件
        /// </summary>
        IDisposable Subscribe<TEvent>(Action<TEvent> handler) where TEvent : IEvent;
        
        /// <summary>
        /// 异步订阅事件
        /// </summary>
        IDisposable Subscribe<TEvent>(Func<TEvent, Task> handler) where TEvent : IEvent;
        
        /// <summary>
        /// 条件订阅事件
        /// </summary>
        IDisposable Subscribe<TEvent>(Func<TEvent, bool> filter, Action<TEvent> handler) where TEvent : IEvent;
    }
}

// ✅ Critical级别：缓存服务
namespace MF.Infrastructure.Abstractions.Caching
{
    /// <summary>
    /// 缓存服务抽象接口
    /// </summary>
    public interface ICacheService
    {
        Task<T?> GetAsync<T>(string key, CancellationToken cancellationToken = default) where T : class;
        Task SetAsync<T>(string key, T value, TimeSpan? expiration = null, CancellationToken cancellationToken = default) where T : class;
        Task<bool> ExistsAsync(string key, CancellationToken cancellationToken = default);
        Task RemoveAsync(string key, CancellationToken cancellationToken = default);
        Task ClearAsync(CancellationToken cancellationToken = default);
        Task<CacheStatistics> GetStatisticsAsync(CancellationToken cancellationToken = default);
    }
}

// ✅ Critical级别：配置服务
namespace MF.Infrastructure.Abstractions.Configuration
{
    /// <summary>
    /// 配置服务抽象接口
    /// </summary>
    public interface IConfigurationService
    {
        T GetValue<T>(string key, T defaultValue = default);
        Task<T> GetValueAsync<T>(string key, T defaultValue = default);
        void SetValue<T>(string key, T value);
        Task SetValueAsync<T>(string key, T value);
        bool HasKey(string key);
        void RemoveKey(string key);
        Task SaveAsync();
        event Action<string, object> ValueChanged;
    }
}
```

#### B. Standard级别：选择抽象

**特征**：
- 中等变化可能性
- 重要但非核心依赖
- 可能需要多种实现
- 测试中等重要性

```csharp
// ✅ Standard级别：日志服务（提供基础抽象）
namespace MF.Infrastructure.Abstractions.Logging
{
    /// <summary>
    /// 游戏日志接口（简化版）
    /// </summary>
    public interface IGameLogger
    {
        void LogDebug(string message, params object[] args);
        void LogInformation(string message, params object[] args);
        void LogWarning(string message, params object[] args);
        void LogError(string message, params object[] args);
        void LogError(Exception exception, string message, params object[] args);
        void LogCritical(string message, params object[] args);
        void LogCritical(Exception exception, string message, params object[] args);
    }
    
    /// <summary>
    /// 日志工厂接口
    /// </summary>
    public interface ILoggerFactory
    {
        IGameLogger CreateLogger(string categoryName);
        IGameLogger CreateLogger<T>();
    }
}

// ✅ Standard级别：资源加载服务
namespace MF.Infrastructure.Abstractions.ResourceLoading
{
    /// <summary>
    /// 资源加载器接口
    /// </summary>
    public interface IResourceLoader
    {
        Task<T?> LoadAsync<T>(string path, CancellationToken cancellationToken = default) where T : Resource;
        Task<bool> ExistsAsync(string path, CancellationToken cancellationToken = default);
        Task<ResourceMetadata> GetMetadataAsync(string path, CancellationToken cancellationToken = default);
        Task PreloadAsync(string path, CancellationToken cancellationToken = default);
        Task UnloadAsync(string path);
    }
}
```

#### C. Minimal级别：最小抽象

**特征**：
- 低变化可能性
- 性能敏感
- 平台特定
- 测试重要性低

```csharp
// ✅ Minimal级别：直接使用具体类
namespace MF.Infrastructure.FileSystem
{
    /// <summary>
    /// Godot文件系统服务（无接口）
    /// </summary>
    public class GodotFileSystem
    {
        public async Task<string> ReadAllTextAsync(string path)
        {
            using var file = FileAccess.Open(path, FileAccess.ModeFlags.Read);
            if (file == null) throw new FileNotFoundException($"File not found: {path}");
            return file.GetAsText();
        }
        
        public async Task WriteAllTextAsync(string path, string content)
        {
            using var file = FileAccess.Open(path, FileAccess.ModeFlags.Write);
            if (file == null) throw new IOException($"Cannot write to file: {path}");
            file.StoreString(content);
        }
        
        public bool Exists(string path) => FileAccess.FileExists(path);
        public bool DirectoryExists(string path) => DirAccess.DirExistsAbsolute(path);
    }
}

namespace MF.Infrastructure.Serialization
{
    /// <summary>
    /// JSON序列化服务（无接口）
    /// </summary>
    public class JsonSerializer
    {
        private readonly JsonSerializerOptions _options;
        
        public JsonSerializer()
        {
            _options = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = true,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
            };
        }
        
        public string Serialize<T>(T obj) => System.Text.Json.JsonSerializer.Serialize(obj, _options);
        public T? Deserialize<T>(string json) => System.Text.Json.JsonSerializer.Deserialize<T>(json, _options);
    }
}

namespace MF.Infrastructure.Platform
{
    /// <summary>
    /// 平台服务（无接口）
    /// </summary>
    public class GodotPlatformService
    {
        public string GetPlatformName() => OS.GetName();
        public string GetVersion() => OS.GetVersion();
        public bool IsMobile() => OS.HasFeature("mobile");
        public bool IsDebugBuild() => OS.IsDebugBuild();
        public Vector2I GetScreenSize() => DisplayServer.ScreenGetSize();
    }
}
```

### 3. 混合抽象实现

```csharp
// ✅ 混合抽象：根据需要选择抽象级别
namespace MF.Infrastructure.Monitoring
{
    /// <summary>
    /// 性能监控服务：Critical级别（需要抽象）
    /// </summary>
    public interface IPerformanceMonitor
    {
        void RecordMetric(string name, double value, Dictionary<string, string>? tags = null);
        void RecordCounter(string name, long value = 1, Dictionary<string, string>? tags = null);
        void RecordTimer(string name, TimeSpan duration, Dictionary<string, string>? tags = null);
        Task<PerformanceReport> GenerateReportAsync(TimeSpan period);
    }
    
    /// <summary>
    /// 内存监控服务：Minimal级别（直接实现）
    /// </summary>
    public class MemoryMonitor
    {
        private readonly Timer _monitorTimer;
        private long _lastMemoryUsage;
        
        public event Action<MemoryPressureEventArgs>? MemoryPressureDetected;
        
        public MemoryMonitor()
        {
            _monitorTimer = new Timer(CheckMemoryUsage, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
        }
        
        public long GetCurrentMemoryUsage() => GC.GetTotalMemory(false);
        
        public void ForceGarbageCollection()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
            GC.Collect();
        }
        
        private void CheckMemoryUsage(object? state)
        {
            var currentUsage = GetCurrentMemoryUsage();
            var threshold = 500 * 1024 * 1024; // 500MB
            
            if (currentUsage > threshold && currentUsage > _lastMemoryUsage * 1.2)
            {
                MemoryPressureDetected?.Invoke(new MemoryPressureEventArgs
                {
                    CurrentUsage = currentUsage,
                    PreviousUsage = _lastMemoryUsage,
                    Threshold = threshold
                });
            }
            
            _lastMemoryUsage = currentUsage;
        }
    }
}
```

## 依赖注入配置

### 1. 分层注册策略

```csharp
// ✅ 基础设施服务注册
namespace MF.Infrastructure.DependencyInjection
{
    public static class InfrastructureServiceExtensions
    {
        public static IServiceCollection AddInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
        {
            // Critical级别：使用接口注册
            services.AddCriticalInfrastructureServices(configuration);
            
            // Standard级别：选择性使用接口
            services.AddStandardInfrastructureServices(configuration);
            
            // Minimal级别：直接注册具体类
            services.AddMinimalInfrastructureServices();
            
            return services;
        }
        
        private static IServiceCollection AddCriticalInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
        {
            // 事件总线：支持多种实现
            var eventBusConfig = configuration.GetSection("EventBus").Get<EventBusConfig>();
            if (eventBusConfig?.UseDistributed == true)
            {
                services.AddSingleton<IEventBus, RedisEventBus>();
            }
            else
            {
                services.AddSingleton<IEventBus, R3EventBus>();
            }
            
            // 缓存服务：支持多种实现
            var cacheConfig = configuration.GetSection("Cache").Get<CacheConfig>();
            if (cacheConfig?.UseRedis == true)
            {
                services.AddStackExchangeRedisCache(options =>
                {
                    options.Configuration = cacheConfig.RedisConnectionString;
                });
                services.AddSingleton<ICacheService, RedisCacheService>();
            }
            else
            {
                services.AddMemoryCache();
                services.AddSingleton<ICacheService, MemoryCacheService>();
            }
            
            // 配置服务：支持多种存储
            services.AddSingleton<IConfigurationService, JsonConfigurationService>();
            
            // 性能监控：支持多种后端
            services.AddSingleton<IPerformanceMonitor, PrometheusPerformanceMonitor>();
            
            return services;
        }
        
        private static IServiceCollection AddStandardInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
        {
            // 日志服务：提供基础抽象
            services.AddSingleton<ILoggerFactory, GodotLoggerFactory>();
            services.AddTransient(typeof(IGameLogger<>), typeof(GameLogger<>));
            
            // 资源加载：可能需要替换
            services.AddSingleton<IResourceLoader, GodotResourceLoader>();
            
            return services;
        }
        
        private static IServiceCollection AddMinimalInfrastructureServices(this IServiceCollection services)
        {
            // 文件系统：平台特定，直接注册
            services.AddSingleton<GodotFileSystem>();
            
            // 序列化：稳定技术，直接注册
            services.AddSingleton<JsonSerializer>();
            
            // 平台服务：Godot特定，直接注册
            services.AddSingleton<GodotPlatformService>();
            
            // 内存监控：性能敏感，直接注册
            services.AddSingleton<MemoryMonitor>();
            
            return services;
        }
    }
}
```

### 2. 配置驱动的实现选择

```json
// appsettings.json
{
  "EventBus": {
    "UseDistributed": false,
    "RedisConnectionString": "localhost:6379",
    "MaxConcurrentHandlers": 10
  },
  "Cache": {
    "UseRedis": false,
    "RedisConnectionString": "localhost:6379",
    "DefaultExpiration": "01:00:00",
    "MaxMemorySize": 104857600
  },
  "Logging": {
    "EnableFileLogging": true,
    "LogLevel": "Information",
    "LogFilePath": "user://logs/game.log"
  },
  "Performance": {
    "EnableMonitoring": true,
    "MetricsEndpoint": "http://localhost:9090/metrics",
    "SampleRate": 0.1
  }
}
```

## 测试策略

### 1. Critical级别服务测试

```csharp
// ✅ Critical级别：完整的Mock测试
[TestFixture]
public class ResourceServiceTests
{
    private Mock<IEventBus> _mockEventBus;
    private Mock<ICacheService> _mockCacheService;
    private Mock<IResourceLoader> _mockResourceLoader;
    private ResourceService _resourceService;
    
    [SetUp]
    public void Setup()
    {
        _mockEventBus = new Mock<IEventBus>();
        _mockCacheService = new Mock<ICacheService>();
        _mockResourceLoader = new Mock<IResourceLoader>();
        
        _resourceService = new ResourceService(
            _mockEventBus.Object,
            _mockCacheService.Object,
            _mockResourceLoader.Object);
    }
    
    [Test]
    public async Task GetResourceAsync_ShouldPublishEvent_WhenResourceLoaded()
    {
        // Arrange
        var expectedResource = new Texture2D();
        _mockResourceLoader.Setup(x => x.LoadAsync<Texture2D>("test.png", default))
                          .ReturnsAsync(expectedResource);
        
        // Act
        var result = await _resourceService.GetResourceAsync<Texture2D>("test.png");
        
        // Assert
        Assert.AreEqual(expectedResource, result);
        _mockEventBus.Verify(x => x.PublishAsync(It.IsAny<ResourceLoadedEvent>(), default), Times.Once);
    }
}
```

### 2. Standard级别服务测试

```csharp
// ✅ Standard级别：部分Mock + 集成测试
[TestFixture]
public class LoggingServiceTests
{
    private Mock<ILoggerFactory> _mockLoggerFactory;
    private Mock<IGameLogger> _mockLogger;
    
    [SetUp]
    public void Setup()
    {
        _mockLoggerFactory = new Mock<ILoggerFactory>();
        _mockLogger = new Mock<IGameLogger>();
        _mockLoggerFactory.Setup(x => x.CreateLogger<TestService>()).Returns(_mockLogger.Object);
    }
    
    [Test]
    public void LogInformation_ShouldCallLogger_WithCorrectMessage()
    {
        // Arrange
        var service = new TestService(_mockLoggerFactory.Object);
        
        // Act
        service.DoSomething();
        
        // Assert
        _mockLogger.Verify(x => x.LogInformation("Something was done"), Times.Once);
    }
}
```

### 3. Minimal级别服务测试

```csharp
// ✅ Minimal级别：集成测试为主
[TestFixture]
public class FileSystemServiceTests
{
    private GodotFileSystem _fileSystem;
    private string _testFilePath;
    
    [SetUp]
    public void Setup()
    {
        _fileSystem = new GodotFileSystem();
        _testFilePath = "user://test_file.txt";
    }
    
    [TearDown]
    public void TearDown()
    {
        if (_fileSystem.Exists(_testFilePath))
        {
            FileAccess.Open(_testFilePath, FileAccess.ModeFlags.Write)?.Close();
        }
    }
    
    [Test]
    public async Task WriteAndReadText_ShouldWorkCorrectly()
    {
        // Arrange
        var testContent = "Hello, World!";
        
        // Act
        await _fileSystem.WriteAllTextAsync(_testFilePath, testContent);
        var result = await _fileSystem.ReadAllTextAsync(_testFilePath);
        
        // Assert
        Assert.AreEqual(testContent, result);
    }
}
```

## 性能影响分析

### 1. 抽象开销对比

```csharp
// 性能基准测试
[MemoryDiagnoser]
[SimpleJob(RuntimeMoniker.Net80)]
public class AbstractionOverheadBenchmark
{
    private IEventBus _abstractEventBus;
    private R3EventBus _concreteEventBus;
    private TestEvent _testEvent;
    
    [GlobalSetup]
    public void Setup()
    {
        _concreteEventBus = new R3EventBus();
        _abstractEventBus = _concreteEventBus;
        _testEvent = new TestEvent { Message = "Test" };
    }
    
    [Benchmark(Baseline = true)]
    public void DirectCall()
    {
        _concreteEventBus.Publish(_testEvent);
    }
    
    [Benchmark]
    public void InterfaceCall()
    {
        _abstractEventBus.Publish(_testEvent);
    }
    
    [Benchmark]
    public void GenericInterfaceCall<T>() where T : IEvent
    {
        _abstractEventBus.Publish((T)(object)_testEvent);
    }
}

// 预期结果：
// DirectCall:           100.0 ns (基准)
// InterfaceCall:        102.5 ns (~2.5% 开销)
// GenericInterfaceCall: 105.0 ns (~5.0% 开销)
```

### 2. 编译时优化

```csharp
// ✅ 使用泛型约束减少运行时开销
public static class ServiceExtensions
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void PublishEvent<TEventBus, TEvent>(this TEventBus eventBus, TEvent @event)
        where TEventBus : IEventBus
        where TEvent : IEvent
    {
        // 编译时确定类型，减少虚函数调用开销
        eventBus.Publish(@event);
    }
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static async Task<T?> GetCachedValue<TCacheService, T>(this TCacheService cache, string key)
        where TCacheService : ICacheService
        where T : class
    {
        // 编译时优化的缓存访问
        return await cache.GetAsync<T>(key);
    }
}
```

## 实施建议

### 1. 渐进式抽象策略

**第一阶段**：Critical级别抽象
- 实现事件总线、缓存服务、配置服务的抽象接口
- 这些是变化最频繁、影响最大的服务

**第二阶段**：Standard级别抽象
- 为日志、资源加载等服务提供基础抽象
- 平衡抽象和性能

**第三阶段**：Minimal级别优化
- 对性能敏感的服务保持直接实现
- 通过编译时优化提升性能

### 2. 抽象决策矩阵

| 服务类型 | 变化频率 | 业务依赖 | 性能敏感度 | 测试重要性 | 推荐抽象级别 |
|----------|----------|----------|------------|------------|-------------|
| 事件总线 | 高 | 高 | 中 | 高 | Critical |
| 缓存服务 | 高 | 高 | 高 | 高 | Critical |
| 配置服务 | 中 | 高 | 低 | 中 | Critical |
| 日志服务 | 中 | 中 | 中 | 中 | Standard |
| 资源加载 | 中 | 高 | 高 | 中 | Standard |
| 文件系统 | 低 | 低 | 高 | 低 | Minimal |
| 序列化 | 低 | 中 | 高 | 低 | Minimal |
| 平台服务 | 低 | 低 | 中 | 低 | Minimal |

### 3. 架构演进路径

```csharp
// 演进路径示例：从Minimal到Critical

// 第一版：直接实现
public class SimpleEventBus
{
    public void Publish<T>(T @event) { /* 简单实现 */ }
}

// 第二版：添加基础抽象
public interface IEventBus
{
    void Publish<T>(T @event);
}

public class SimpleEventBus : IEventBus
{
    public void Publish<T>(T @event) { /* 实现 */ }
}

// 第三版：完整抽象
public interface IEventBus
{
    Task PublishAsync<T>(T @event) where T : IEvent;
    IDisposable Subscribe<T>(Action<T> handler) where T : IEvent;
    // 更多高级功能...
}
```

## 总结

### 核心建议

**基础设施层需要抽象接口，但应该采用分层抽象策略**：

1. **Critical级别**：必须抽象
   - 事件总线、缓存服务、配置服务
   - 高变化可能性，核心业务依赖

2. **Standard级别**：选择抽象
   - 日志服务、资源加载服务
   - 提供基础抽象，平衡性能和灵活性

3. **Minimal级别**：最小抽象
   - 文件系统、序列化、平台服务
   - 性能敏感，变化可能性低

### 实施原则

1. **按需抽象**：不是所有服务都需要抽象
2. **性能优先**：游戏开发中性能是关键考虑因素
3. **渐进演进**：从简单开始，根据需要增加抽象
4. **测试驱动**：抽象的主要目的是提高可测试性
5. **配置驱动**：通过配置选择不同的实现

这种分层抽象策略既保证了架构的灵活性和可测试性，又避免了过度抽象带来的性能开销，是基础设施层设计的最佳实践。